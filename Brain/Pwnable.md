[[Package - Pwntools]]
[[Shellcode]]

# tty를 이용한 쉘 업그레이드
쉘 따고 나서 쓰면 됨
	python3 -c 'import pty; pty.spawn("/bin/bash")'


# 리눅스 프로세스의 메모리 구조
리눅스에서는 프로세스의 메모리를 크게 5가지의 **세그먼트(Segment)** 로 구분됨

|**세그먼트**|**역할**|**일반적인 권한**|**사용 예**|
|---|---|---|---|
|코드 세그먼트|실행 가능한 코드가 저장된 영역|읽기, 실행|main() 등의 함수 코드|
|데이터 세그먼트|초기화된 전역 변수 또는 상수가 위치하는 영역|읽기와 쓰기 또는 읽기 전용|초기화된 전역 변수, 전역 상수|
|BSS 세그먼트|초기화되지 않은 데이터가 위치하는 영역|읽기, 쓰기|초기화되지 않은 전역 변수|
|스택 세그먼트|임시 변수가 저장되는 영역|읽기, 쓰기|지역 변수, 함수의 인자 등|
|힙 세그먼트|실행중에 동적으로 사용되는 영역|읽기, 쓰기|malloc(), calloc() 등으로 할당 받은 메모리|

### 코드 세그먼트(Code Segment)
실행 가능한 기계 코드가 위치하는 영역
텍스트 세그먼트(Text Segment)라고도 불립니다.

프로그램이 동작하려면 코드를 실행할 수 있어야 하므로 읽기 권한 과 실행 권한 이 부여됨
반면 쓰기 권한이 있으면 공격자가 악의적인 코드를 삽입하기가 쉬워지므로, 대부분의 현대 운영체제는 이 세그먼트에 쓰기 권한을 제거함

### 데이터 세그먼트(Data Segment)
컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치
CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로, 읽기 권한이 부여

- data 세그먼트
쓰기가 가능한 세그먼트는 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치

- rodata(read-only data) 세그먼트
쓰기가 불가능한 세그먼트에는 프로그램이 실행되면서 값이 변하면 안되는 데이터들이 위치
전역으로 선언된 상수

### BSS 세그먼트(BSS Segment, Block Started By Symbol Segment)
컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 메모리 영역
개발자가 선언만 하고 초기화하지 않은 전역변수
이 세그먼트의 메모리 영역은 프로그램이 시작될 때, 모두 0으로 값이 초기화됨(C 코드를 작성할 때, 초기화되지 않은 전역 변수의 값은 0이 됨)
읽기 권한 및 쓰기 권한이 부여


## 스택 세그먼트(Stack Segment)
함수의 인자나 지역 변수와 같은 임시 변수들이 실행중에 여기에 저장
어떤 프로세스가 실행될 때, 이 프로세스가 얼마 만큼의 스택 프레임을 사용하게 될 지를 미리 계산하는 것은 일반적으로 불가능하기 때문에,
운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당해주고, 부족해 질 때마다 이를 확장해줌
스택에 대해서 ‘아래로 자란다' 라는 표현을 종종 사용하는데, 이는 스택이 확장될 때, 기존 주소보다 낮은 주소로 확장되기 때문
읽기 와 쓰기 권한 이 부여


### 힙 세그먼트(Heap Segment)
스택과 마찬가지로 실행중에 동적으로 할당될 수 있음
택 세그먼트와 반대 방향으로 자람
읽기와 쓰기 권한이 부여


# 어셈블리어 기본 명령어
|명령 코드|   |
|---|---|
|데이터 이동(Data Transfer)|`mov`, `lea`|
|산술 연산(Arithmetic)|`inc`, `dec`, `add`, `sub`|
|논리 연산(Logical)|`and`, `or`, `xor`, `not`|
|비교(Comparison)|`cmp`, `test`|
|분기(Branch)|`jmp`, `je`, `jg`|
|스택(Stack)|`push`, `pop`|
|프로시져(Procedure)|`call`, `ret`, `leave`|
|시스템 콜(System call)|`syscall`|



# 메모리 피연산자
|메모리 피연산자|   |
|---|---|
|QWORD PTR [0x8048000]|0x8048000의 데이터를 8바이트만큼 참조|
|DWORD PTR [0x8048000]|0x8048000의 데이터를 4바이트만큼 참조|
|WORD PTR [rax]|rax가 가르키는 주소에서 데이터를 2바이트 만큼 참조|



# 크기 단위
- bit
1 or 0

- byte
아스키코드 하나를 나타낼 수 있음(=글자 하나 크기)
0x00 ~ 0xFF

- word
~~아키텍처에 따라 유동적으로 변함
아키텍처마다 다르지만, 일반적으로 32비트 컴퓨터이면 32비트
64비트 컴퓨터이면 word가 64비트가 됨
주소의 크기와 동일~~

인텔의 경우에는 새로운 아키텍처와 호환되지 않을 수 있음을 우려하여 기존에 사용하던 WORD의 크기(2바이트)를 그대로 유지하고, 
DWORD(Double Word, 32bit)와 QWORD(Quad Word, 64bit)자료형을 추가로 만들었음

# 시스템 콜
운영체제는 연결된 모든 하드웨어 및 소프트웨어에 접근할 수 있으며, 이들을 제어함
해킹으로부터 이 막강한 권한을 보호하기 위해 커널 모드와 유저 모드로 권한을 나눔

- 커널 모드
운영체제가 전체 시스템을 제어하기 위해 시스템 소프트웨어에 부여하는 권한
파일시스템, 입력/출력, 네트워크 통신, 메모리 관리 등 모든 저수준의 작업은 사용자 모르게 커널 모드에서 진행
커널 모드에서는 시스템의 모든 부분을 제어할 수 있기 때문에, 해커가 커널 모드까지 진입하게 되면 시스템은 거의 무방비 상태가 됨

- 유저 모드
운영체제가 사용자에게 부여하는 권한
리눅스에서 루트 권한으로 사용자를 추가하고, 패키지를 내려 받는 행위
유저 모드에서는 해킹이 발생해도, 해커가 유저 모드의 권한까지 밖에 획득하지 못하기 때문에 해커로 부터 커널의 막강한 권한을 보호할 수 있음

-  시스템 콜(system call, syscall)
유저 모드에서 커널 모드의 시스템 소프트웨어에게 어떤 동작을 요청하기 위해 사용

![[Pasted image 20231024220518.png]]

x64아키텍처에서는 시스템콜을 위해 `syscall` 명령어가 있음