Position-Independent Executable(PIE)
# 배경
ASLR이 적용되어 있으면 바이너리가 실행될 때마다 스택, 힙, 공유 라이브러리 등이 무작위 주소에 매핑되는 효과를 받음
하지만 `main` 함수의 주소는 매번 같은 현상을 확인할 수 있음
이런 특징을 이용하여 공격자는 고정된 주소의 코드 가젯을 활용한 ROP를 수행할 수 있기 때문에 이러한 코드 영역에도 ASLR 기술이 적용되게 하는 기술을 PIE라고 함
이 기술은 보안성 향상을 위해 도입된 것이 아니라서 엄밀하게는 보호 기법이 아니라고 함
ASLR을 꺼도 PIE가 적용된 프로세스는 무작위 주소에 매핑됨


# PIC
리눅스에서 ELF는 실행 파일(Executable)과 공유 오브젝트(Shared Object, SO)로 두 가지가 존재
공유 오브젝트는 기본적으로 재배치(Relocation)가 가능하도록 설계되어 있음
즉, 메모리의 어느 주소에 적재되어도 코드의 의미가 훼손되지 않음
컴퓨터 과학에서는 이런 성질을 만족하는 코드를 Position-Independent Code(PIC)라고 부름

`no_pic`와 `pic`의 `main` 함수를 비교해보면, `main+14`에서 “%p” 문자열을 `printf`에 전달하는 방식이 다름
`no_pic`에서는 `0x4005a1`라는 절대 주소로 문자열을 참조하고 있지만 `pic`는 문자열의 주소를 `rip+0xa2`로 참조하고 있음
```
$ gdb ./no_picpwndbg> x/s 0x4005a10x4005a1:       "%p"
```

```
$ gdb ./picpwndbg> x/s 0x7110x711:  "%p"
```

`pic`의 코드는 `rip`를 기준으로 데이터를 상대 참조(Relative Addressing)하기 때문에 바이너리가 무작위 주소에 매핑돼도 제대로 실행될 수 있게 됨

ASLR이 도입되기 전 초기에는 실행 파일을 무작위 주소에 매핑할 필요가 없었기 때문에 리눅스의 실행 파일 형식은 재배치를 고려하지 않고 설계되었음
이후에 ASLR이 도입되었을 때는 실행 파일도 무작위 주소에 매핑될 수 있게 하고 싶었으나, 
이미 널리 사용되는 실행 파일의 형식을 변경하면 호환성 문제가 발생할 것이 분명했기 때문에 개발자들은 원래 재배치가 가능했던 공유 오브젝트를 실행 파일로 사용하기로 했음

실제로 `ls`명령어의 파일 헤더를 보면, `Type`이 공유 오브젝트(Shared Object)를 나타내는 `DYN`(`ET_DYN`) 임을 알 수 있다고 함


# PIE 우회
1. 코드 베이스를 구하기
라이브러리의 베이스 주소를 구할 때 처럼 코드 영역의 임의 주소를 읽고, 그 주소에서 오프셋을 빼는 방법

2. Partial Overwrite
반환 주소의 일부 바이트만 덮는 공격
일반적으로 함수의 반환 주소는 호출 함수(Caller)의 내부를 가리킴
특정 함수의 호출 관계는 정적 분석 또는 동적 분석으로 쉽게 확인할 수 있으므로, 공격자는 반환 주소를 예측할 수 있음
ASLR의 특성 상, 코드 영역의 주소도 하위 12비트 값은 항상 같음
따라서 사용하려는 코드 가젯의 주소가 반환 주소와 하위 한 바이트만 다르다면, 이 값만 덮어서 원하는 코드를 실행시킬 수 있음
그러나 만약 두 바이트 이상이 다른 주소로 실행 흐름을 옮기고자 한다면, ASLR로 뒤섞이는 주소를 맞춰야 하므로 브루트 포싱이 필요




