### 반복문 ~ 함수

- for, while, do while
- break, continue 사용법
- 이중 반복문에서의 break, continue 주의점
- 배열, 인덱스 참조 방법
- 2차원 배열
- n차원 배열
- 함수, 매개변수, 반환값
- 함수의 스코프
- 재귀함수
- 함수 포인터
- 가변인자


  ---
**1. 다음 중 반복문에 대한 설명으로 옳은 것은?**

- [x]   `for`문은 초기화, 조건 검사, 업데이트 세 부분으로 구성된다.
- [ ]   `do while`문은 조건 검사 결과에 따라 반복문 내의 코드를 한번도 실행하지 않을 수 있다.
- [ ]   `for(;;){}`은 `while(0){}`과 동일한 동작을 한다.
- [x]   `while`문은 조건이 참인 동안 계속해서 반복문 내의 코드를 실행한다.

**답 : 1, 2, 3**

1. `for`문은 초기화, 조건 검사, 업데이트 세 부분으로 구성되어 있습니다. 초기화 부분에서는 반복문의 시작 전에 한 번만 실행되는 코드를 작성하고, 조건 검사 부분에서는 반복문을 계속 실행할 지 결정하는 조건을 작성합니다. 그리고 업데이트 부분에서는 반복문의 각 반복 후에 실행되는 코드를 작성합니다.
2. `do while`문은 조건 검사 전에 반복문 내의 코드를 먼저 한 번 실행합니다. 따라서 조건이 거짓이더라도 반복문 내의 코드는 최소한 한 번은 실행됩니다.
3. `for(;;){}`은 무한루프를 돌게 만드므로,  `while(0){}`가 아닌 `while(1){}`과 동일한 효과를 냅니다.
4. `while`문은 조건이 참인 동안 계속해서 반복문 내의 코드를 실행합니다. 만약 조건이 처음부터 거짓이라면 반복문 내의 코드는 한 번도 실행되지 않습니다.

---
**2. 다음 중 break, continue에 대한 설명으로 옳은 것은?**

- [ ]   이중 반복문에서 `break`문을 사용하면, 모든 반복문을 종료한다.
- [x]  `continue`문은 해당 반복문의 나머지 부분을 건너뛰고, 이어서 다음 반복을 진행한다.
- [x]  `for`문에서 continue는 증감식에 영향을 준다.
- [ ] break, continue 문은 오직 분기문에서만 사용이 가능하다.

**답 : 1, 2**

1. 이중 반복문에서 `break`문을 사용하면, `break`문이 속한 반복문만 종료됩니다. 즉, `break`문이 속한 가장 가까운 반복문만 종료되고, 바깥쪽 반복문은 계속해서 실행됩니다.
2. `continue`문은 해당 반복문의 나머지 부분을 건너뛰고, 이어서 다음 반복을 진행합니다. 
3. `for`문에서 `continue`를 사용하면 현재 반복에서 남은 코드를 건너뛰고 증감식으로 이동하게 됩니다.
4. `break`, `continue` 키워드는 분기문이 아닌 반복문에서 사용합니다. `switch`문은 `break`문이 가능하지만 일반적으로 분기문에서 해당 키워드를 사용하지 않습니다.
---
**3. 다음 보기 순서대로 명령어를 실행하려고 한다. 오류가 발생하는 부분은?**
- [ ] `int a[10]={1,2,3,4,5,6,7,8,9,10};`
- [ ] `a[3]=a[2]++;`
- [x] `a[10]=4;`
- [ ] `a[2]='a';`

**답 : 1, 2, 3**

1. 이 명령어는 정수형 배열 `a`를 선언하고 초기화합니다.
2. 이 명령어는 배열 `a`의 세 번째 원소에 두 번째 원소의 값을 대입하고, 두 번째 원소의 값을 1 증가시킵니다.
3. C 언어는 0부터 인덱싱을 시작하므로, 크기가 10인 배열 `a`의 마지막 원소는 `a[9]`입니다. 따라서 `a[10]`은 배열 `a`의 범위를 넘어선 접근이므로, 이 명령어는 오류를 발생시킵니다.
4. 이 명령어는 배열 `a`의 세 번째 원소에 문자 'a'의 ASCII 값(97)을 대입하는 것입니다. C 언어에서는 문자를 정수형 변수에 대입할 수 있으므로, 이 명령어는 기술적으로 문제가 없습니다. 다만 배열 `a`가 정수를 저장하기 위한 것이라는 컨텍스트를 고려하면, 이 명령어는 약간 어색할 수 있습니다.
---
**4. 다음 배열에 대한 코드를 보고 "KnockOn!!" 이라는 문자열을 출력하지 못하는 것은?

```c
char arr[2][6] = { "Knock","On!!"};
```

1.
```c
for (int i = 0; i < 2; i++)
{
	printf("%s", arr[i]);
}
```

2.
```c
for (int i = 0; i < 2; i++)
{
	for (int j = 0; j < 6; j++)
	{
		printf("%c", arr[i][j]);
	}
}
```

3.
```c
for (int i = 0; i < 12; i++)
{
	printf("%c", *(*arr + i));
}
```

4.
```c
for (int i = 0; i < 12; i++)
{
	printf("%c", **(arr + i));
}
```


**답 : 4**

4번을 제외한 모두는 `KnockOn!!`이라는 문자열을 출력합니다. 다만 배열에서 아직 초기화하지 않은 부분도 접근했으므로 무의미한 값이 같이 출력될 수도 있습니다.
4번은 배열 내부 각각의 요소가 아닌 각 행의 첫 번째 요소만 접근하게 됩니다.

---
**5. 다음 중 다차원 배열에 대한 설명으로 옳은 것은?**

- [x]  n차원 배열은 n개의 인덱스를 사용하여 데이터에 접근할 수 있다.
- [ ]  n차원 배열은 n개의 다른 자료형을 저장할 수 있다.
- [x]  n차원 배열의 각 요소는 연속적인 메모리 주소에 할당된다.
- [ ]  다차원 배열은 1차원 배열보다 메모리 사용 효율이 더 좋다.

**답 : 1, 3**

1. n차원 배열은 n개의 인덱스를 사용하여 데이터에 접근할 수 있습니다. 예를들어 2차원 배열은 2개의 인덱스(행과 열)를 사용하여 요소에 접근합니다.
2. 다차원이든 1차원이든, 하나의 배열의 모든 요소는 동일한 자료형을 가져야 합니다.
3. 다차원 배열의 요소는 메모리에 연속적으로 저장되며, 이는 1차원 배열의 경우와 동일합니다.
4. 다차원 배열, 1차원 배열 모두 동일한 양의 데이터를 저장하는 데 동일한 양의 메모리를 사용합니다.
---

**6. 다음 중 함수에 대한 설명으로 옳은 것은?**

- [x]  C 언어에서 함수의 매개변수는 기본적으로 값에 의한 전달(call by value)이다.
- [ ]  C 언어에서 함수는 같은 이름을 가지지만 매개변수의 타입이나 개수가 다른 여러 버전을 가질 수 있다.
- [ ]  C 언어에서 함수 내부에서 선언된 변수는 함수가 종료되더라도 그 값을 유지한다.
- [ ]  C 언어에서 함수는 반드시 main 함수 내부에서만 호출할 수 있다.

**답 : 1**

1. 함수의 매개변수는 기본적으로 값에 의한 전달(call by value)입니다. 이는 함수에 값을 전달할 때, 값이 복사되어 전달되는 것을 의미합니다. 따라서 함수 내에서 매개변수 값을 변경해도, 이는 원래 변수에는 영향을 미치지 않습니다.
2. C 언어는 같은 이름을 가지지만 매개변수의 타입이나 개수가 다른 여러 버전의 함수를 가질 수 없습니다. 각 함수는 고유한 이름을 가져야 합니다. 다만 객체지향을 지원하는 C++, Java과 같은 언어는 함수 오버로딩이라는 것을 통해 하나의 함수가 여러 타입을 가지는 호과를 낼 수 있습니다.
3. C 언어에서 함수 내부에서 선언된 변수는 함수가 종료되면 메모리에서 해제되므로 값을 유지하지 않습니다. 이런 변수를 지역 변수라고 부르며, 함수가 호출될 때 생성되고 함수가 종료되면 소멸합니다.
4. C 언어에서 함수는 main 함수 외부에서도 호출할 수 있습니다. 즉, 다른 함수 내부에서도 함수를 호출할 수 있습니다.
---
**7. 다음 중 함수의 스코프(scope)에 대한 설명으로 옳은 것은?**

- [x]  전역 변수는 모든 함수 내에서 접근이 가능하지만, 지역 변수로 동일한 이름의 변수가 선언되면 전역 변수는 접근할 수 없다.
- [x]  함수 내부에서 선언된 지역 변수는 동일한 함수 내의 중첩된 블록에서 접근할 수 있다.
- [ ]  함수의 매개변수는 함수 외부에서도 접근할 수 있다.
- [x]  전역 변수보다 지역 변수가 우선적으로 참조된다.

**답 : 1, 2, 4**

1. 전역 변수는 모든 함수에서 접근이 가능합니다. 하지만, 지역 변수로 동일한 이름의 변수가 선언되면 해당 함수 내에서는 지역 변수가 우선적으로 참조됩니다. 따라서 해당 영역에서는 전역 변수에 직접적으로 접근할 수 없습니다.
2. 블록 내부에서 자신보다 외부에 선언된 변수에 접근이 가능합니다. 따라서 함수 내부에서 선언된 지역 변수는 동일한 함수 내의 중첩된 블록에서 접근 가능합니다. 
3. 함수의 매개변수는 그 함수 내부에서만 접근 가능합니다. 함수 외부에서는 접근할 수 없습니다.
4. 지역 변수와 전역 변수의 이름이 동일할 경우, 지역 변수가 우선적으로 참조됩니다.

---

**8. 다음 중 가변인자에 대한 설명으로 옳은 것은?**

- [x]  가변인자는 개수가 정해지지 않은 인자를 함수에 전달하는 데 사용된다.
- [ ]  `stdlib.h` 헤더 파일에 정의된 매크로를 사용하여 가변인자를 처리할 수 있다.
- [x]  가변인자 함수는 가변인자 이전에 적어도 하나의 고정 인자를 가져야 한다.
- [ ]  가변인자 함수는 가변인자의 개수를 자동으로 파악할 수 있다.

**답 : 1, 3**

1. 가변인자는 개수가 정해지지 않은 인자를 함수에 전달하는 데 사용됩니다. 가변인자를 사용하면 필요한 만큼의 인자를 함수에 전달할 수 있습니다.
2. `stdlib.h` 헤더 파일이 아닌 `stdarg.h` 헤더 파일에 정의된 매크로를 사용하여 가변인자를 처리할 수 있습니다. 이 매크로를 사용하면 가변인자의 개수와 타입에 상관없이 인자를 순차적으로 읽어올 수 있습니다.
3. 가변인자 함수는 가변인자 이전에 적어도 하나의 고정 인자를 가져야 합니다. 이 고정 인자는 가변인자의 시작을 알리는 역할을 합니다.
4. 가변인자 함수는 가변인자의 개수를 자동으로 파악할 수 없습니다. 따라서 가변인자의 개수를 처리하는 방법을 따로 구현해야 합니다. 가장 일반적인 방법은 고정 인자를 사용하여 가변인자의 개수를 전달하는 것입니다.

---
**9. 아래의 팩토리얼을 계산하는 함수를 완성하시오.**
```c
//fac.c
int factorial(int n) {
	//여기에 작성
}

int main()
{   
    printf("%d", factorial(5));
    return 0;
}
```

**실행결과**
```sh
$ gcc fac.c -o fac
$ ./fac
120
```


**답 :**
```c
int factorial(int n) {
    if (n == 0) 
        return 1;
    
    return factorial(n - 1) * n;
}

int main()
{   
    printf("%d", factorial(5));
    return 0;
}
```
풀이에서는 재귀함수를 통해 작성하였지만, 반복문을 통해 해결할 수도 있습니다. 

---

**10. 다음 중 함수 포인터에 선언부를 작성하시오.**
```c
int add(int a, int b) {
	return a + b;
}

int sub(int a, int b) {
	return a - b;
}

int main() {
	//함수 포인터 fp 선언

	fp = add;
	printf("%d\n", fp(5, 3));

	fp = sub;
	printf("%d\n", fp(5, 3));
}
```

**답 : 
```c
int (*fp)(int, int);
```

---
