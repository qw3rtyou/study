### 동적할당 ~ 파일입출력
- 동적 할당과 구조체
- typedef
- 동적할당의 주의점과 메모리 누수
- 파일 열기, 닫기, 읽기 쓰기
- 파일 위치 지시자, 제어함수들
- 파일 디스크립터

--- 

**1. 다음 코드에서 구조체에 관한 설명으로 올바른 것은?**
```c
typedef struct {
    int x;
    int y;
} element;

typedef struct {
    element stack[MAX_STACK_SIZE];
    int top;
} StackType;
```

- [ ]  `StackType`은 요소 `x`와 `y`만을 포함하는 단일 구조체이다.
- [x]  `StackType`은 `element` 타입의 배열과 정수형 `top`을 멤버로 가지는 구조체이다.
- [ ]  `element` 구조체는 최대 `MAX_STACK_SIZE`개의 `int` 타입 변수를 저장할 수 있다.
- [ ]  `StackType` 구조체는 `top`이라는 이름의 함수 포인터를 멤버로 가지고 있다.

**답 : 2**

**해설:** `element` 구조체는 두 개의 정수형 멤버 `x`와 `y`를 가집니다. `StackType` 구조체는 이러한 `element` 구조체들의 배열을 멤버로 하여 스택을 구현합니다. 배열은 `MAX_STACK_SIZE` 정의에 따라 크기가 정해지며, 스택의 현재 상태를 나타내는 `top` 인덱스도 포함합니다. 이 인덱스는 스택에 저장된 마지막 요소의 위치를 가리키는 용도로 사용됩니다.
(아직 스택을 배우지 않아서 '`top` 인덱스', '스택에 저장된 마지막 요소의 위치' 이런 표현이 익숙하지 않을 수 있습니다. 추후에 스택과 같은 자료구조에 대해서도 배우게 되니 실질적인 의미는 아직 모르셔도 괜찮습니다.)

---

**2. 다음 코드에서 잠재적인 문제로 적절한 것은?
```c
int *allocateArray(int size) {
    return malloc(size * sizeof(int));
}

int main() {
    int *array = allocateArray(100);
    array[50] = 123;
    free(array);
    array[50] = 456;
}
```

- [ ]  `malloc`으로 할당한 메모리의 크기가 충분하지 않아, `array[50]`에 접근할 때 버퍼 오버플로우가 발생한다.
- [ ]  `allocateArray` 함수는 `size`에 음수 값을 전달할 수 있기 때문에, 동적 할당이 실패하고 `array` 포인터는 `NULL`이 될 수 있다.
- [x]  `free` 함수 호출 이후 `array`에 접근하는 것은 해제된 메모리 영역을 다시 사용하려는 시도로, 정의되지 않은 행동(UB)을 초래한다.
- [ ]  `free(array);` 이후에 `array = NULL;`을 설정하지 않았기 때문에, `array`는 여전히 해제된 메모리 주소를 가리키고 있어 추후 할당 오류를 일으킬 수 있다.

**답 : 3**

동적으로 할당된 메모리를 `free` 함수로 해제한 후에 해당 메모리에 다시 접근하는 것은 안전하지 않으며, 프로그램의 예측 불가능한 동작을 야기할 수 있습니다. 이와 같은 상황은 특히 메모리 관련 오류의 원인이 되며, 보안 취약점으로 이어질 수 있습니다.

**해설:** `free` 호출 후에는 해당 포인터를 "댕글링 포인터(dangling pointer)"라고 하며, 이는 더 이상 유효하지 않은 메모리를 가리키고 있습니다. `free` 이후에 `array`를 `NULL`로 설정하면 이후에 해당 포인터를 사용할 때 오류를 예방할 수 있지만, 이 코드에서는 그렇게 하지 않았습니다. 따라서 `array[50] = 456;`은 정의되지 않은 행동을 일으키며, 이는 프로그램의 충돌이나 보안 취약점으로 이어질 수 있습니다. 선지 4는 이러한 상황을 예방하기 위한 좋은 프로그래밍 관행을 언급하고 있습니다.

---

**3. 다음 코드에서 파일 입출력 작업이 끝난 후 필요한 조치로 올바른 것은?
```c
FILE *file = fopen("example.txt", "r+");
fread(buffer, sizeof(char), 100, file);
rewind(file);
fwrite(buffer, sizeof(char), 100, file);
// 필요한 조치 작성
```

- [ ]  `fflush(file);`
- [x]  `fclose(file);`
- [ ]  `fopen(file);`
- [ ]  `fseek(file, 0, SEEK_END);`

**답 : 2**

파일 입출력 작업이 끝난 후에는 반드시 `fclose` 함수를 사용하여 파일 스트림을 닫아주어야 합니다. 이렇게 하지 않으면 파일이 제대로 닫히지 않고 메모리 누수가 발생할 수 있습니다.

---

**4. 다음 코드에서 `fseek` 함수를 사용한 결과로 올바른 것은?
```c
FILE *file = fopen("example.txt", "r+");
fseek(file, -2, SEEK_END);
fprintf(file, "XY");
fclose(file);
```

- [ ]  파일의 끝에서부터 2바이트 앞으로 이동한 후, "XY"를 쓸 것이다.
- [x]  파일의 마지막에서 두 번째 바이트를 "XY"로 덮어쓸 것이다.
- [ ]  `fseek`는 `SEEK_END`를 사용할 때 음수를 인자로 취할 수 없으므로 오류가 발생한다.
- [ ]  파일의 끝에서 2바이트 뒤에 "XY"를 추가할 것이다.

**답 : 2**

`fseek` 함수를 `SEEK_END`와 함께 사용하면 파일의 끝을 기준으로 위치를 이동할 수 있으며, 음수를 이용하여 파일 끝에서부터 거꾸로 이동할 수 있습니다. 따라서 이 코드는 파일의 마지막에서 두 번째 바이트 위치에 "XY"를 쓰게 됩니다.

---

**5. UNIX 시스템에서 `read` 시스템 호출을 사용하여 파일 디스크립터 3번에서 데이터를 읽으려 할 때, 적절한 사용법은?
```c
char buffer[100];
int nbytes = read(3, buffer, 100);
```

- [x]  위 코드는 파일 디스크립터 3번에서 최대 100바이트를 `buffer`로 읽어들인다.
- [ ]  `read` 함수는 파일 디스크립터 대신 `FILE *` 타입을 사용해야 한다.
- [ ]  파일 디스크립터 3번은 존재하지 않으므로 이 코드는 실패할 것이다.
- [ ]  `read` 함수는 문자열만 읽을 수 있으므로 `buffer`는 문자열 타입이어야 한다.

**답 : 1**

`read` 시스템 호출은 주어진 파일 디스크립터에서 데이터를 읽어들이는 데 사용되며, 이 경우 파일 디스크립터 3번에서 최대 100바이트를 읽어 `buffer`에 저장합니다. 파일 디스크립터 3번은 이미 어떤 파일에 대해 열려 있을 수 있습니다.