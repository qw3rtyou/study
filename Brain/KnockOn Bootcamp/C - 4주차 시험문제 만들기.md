### 동적할당 ~ 파일입출력
- 동적 할당과 구조체
- typedef
- 동적할당의 주의점과 메모리 누수
- 파일 열기, 닫기, 읽기 쓰기
- 파일 위치 지시자, 제어함수들
- 파일 디스크립터

--- 

**1. 다음 코드에서 `NewType`의 정의에 관한 설명으로 올바른 것은?
```c
typedef struct {
    int x;
    int y;
} Point;

typedef Point NewType;
```

- [ ]  `NewType`는 `Point`와 다른 새로운 구조체 타입이다.
- [x]  `NewType`는 `Point` 구조체에 대한 별칭으로, `Point`와 동일한 타입이다.
- [ ]  `NewType`는 `Point`의 복사본으로, 서로 독립적인 타입이다.
- [ ]  `Point`와 `NewType`은 서로 호환되지 않는 별개의 타입이다.

**답 : 2**

`typedef`를 사용하여 `Point` 타입에 `NewType`이라는 새로운 이름을 부여했으며, 두 타입은 완전히 동일합니다.

---

**2. 다음 코드에서 잠재적인 문제로 적절한 것은?
```c
int *allocateArray(int size) {
    return malloc(size * sizeof(int));
}

int main() {
    int *array = allocateArray(100);
    array[50] = 123;
    free(array);
    array[50] = 456;
}
```

- [ ]  `malloc`으로 할당한 메모리는 자동으로 해제되므로 `free`를 호출할 필요가 없다.
- [ ]  `array[50]`는 할당된 범위를 벗어나므로 잘못된 메모리 접근이다.
- [x]  `free` 후에 `array`를 사용하는 것은 잘못된 메모리 접근으로, 메모리 누수나 오류를 유발할 수 있다.
- [ ]  `allocateArray` 함수에서 `malloc`을 사용할 때 `size`를 검증하지 않아 문제가 될 수 있다.

**답 : 3**

`free` 함수 호출 후에 할당 해제된 메모리를 사용하는 것은 정의되지 않은 행동(UB)으로, 실행 시 오류를 일으킬 수 있습니다.

---

**3. 다음 코드에서 파일 입출력 작업이 끝난 후 필요한 조치로 올바른 것은?
```c
FILE *file = fopen("example.txt", "r+");
fread(buffer, sizeof(char), 100, file);
rewind(file);
fwrite(buffer, sizeof(char), 100, file);
// 필요한 조치 작성
```

- [ ]  `fflush(file);`
- [x]  `fclose(file);`
- [ ]  `fopen(file);`
- [ ]  `fseek(file, 0, SEEK_END);`

**답 : 2**

파일 입출력 작업이 끝난 후에는 반드시 `fclose` 함수를 사용하여 파일 스트림을 닫아주어야 합니다. 이렇게 하지 않으면 파일이 제대로 닫히지 않고 메모리 누수가 발생할 수 있습니다.

---

**4. 다음 코드에서 `fseek` 함수를 사용한 결과로 올바른 것은?
```c
FILE *file = fopen("example.txt", "r+");
fseek(file, -2, SEEK_END);
fprintf(file, "XY");
fclose(file);
```

- [ ]  파일의 끝에서부터 2바이트 앞으로 이동한 후, "XY"를 쓸 것이다.
- [x]  파일의 마지막에서 두 번째 바이트를 "XY"로 덮어쓸 것이다.
- [ ]  `fseek`는 `SEEK_END`를 사용할 때 음수를 인자로 취할 수 없으므로 오류가 발생한다.
- [ ]  파일의 끝에서 2바이트 뒤에 "XY"를 추가할 것이다.

**답 : 2**

`fseek` 함수를 `SEEK_END`와 함께 사용하면 파일의 끝을 기준으로 위치를 이동할 수 있으며, 음수를 이용하여 파일 끝에서부터 거꾸로 이동할 수 있습니다. 따라서 이 코드는 파일의 마지막에서 두 번째 바이트 위치에 "XY"를 쓰게 됩니다.

---

**5. UNIX 시스템에서 `read` 시스템 호출을 사용하여 파일 디스크립터 3번에서 데이터를 읽으려 할 때, 적절한 사용법은?
```c
char buffer[100];
int nbytes = read(3, buffer, 100);
```

- [x]  위 코드는 파일 디스크립터 3번에서 최대 100바이트를 `buffer`로 읽어들인다.
- [ ]  `read` 함수는 파일 디스크립터 대신 `FILE *` 타입을 사용해야 한다.
- [ ]  파일 디스크립터 3번은 존재하지 않으므로 이 코드는 실패할 것이다.
- [ ]  `read` 함수는 문자열만 읽을 수 있으므로 `buffer`는 문자열 타입이어야 한다.

**답 : 1**

`read` 시스템 호출은 주어진 파일 디스크립터에서 데이터를 읽어들이는 데 사용되며, 이 경우 파일 디스크립터 3번에서 최대 100바이트를 읽어 `buffer`에 저장합니다. 파일 디스크립터 3번은 이미 어떤 파일에 대해 열려 있을 수 있습니다.