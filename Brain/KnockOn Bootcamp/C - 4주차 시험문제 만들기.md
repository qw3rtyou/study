### 동적할당 ~ 파일입출력
- 동적 할당과 구조체
- typedef
- 동적할당의 주의점과 메모리 누수
- 파일 열기, 닫기, 읽기 쓰기
- 파일 위치 지시자, 제어함수들
- 파일 디스크립터

--- 

**1. 다음 코드에서 구조체에 관한 설명으로 올바른 것은?**
```c
typedef struct {
    int x;
    int y;
} element;

typedef struct {
    element stack[MAX_STACK_SIZE];
    int top;
} StackType;
```

- [ ]  `StackType`은 요소 `x`와 `y`만을 포함하는 단일 구조체이다.
- [x]  `StackType`은 `element` 타입의 배열과 정수형 `top`을 멤버로 가지는 구조체이다.
- [ ]  `element` 구조체는 최대 `MAX_STACK_SIZE`개의 `int` 타입 변수를 저장할 수 있다.
- [ ]  `StackType` 구조체는 `top`이라는 이름의 함수 포인터를 멤버로 가지고 있다.

**답 : 2**

`element` 구조체는 두 개의 정수형 멤버 `x`와 `y`를 가집니다. `StackType` 구조체는 이러한 `element` 구조체들의 배열을 멤버로 하여 스택을 구현합니다. 배열은 `MAX_STACK_SIZE` 정의에 따라 크기가 정해지며, 스택의 현재 상태를 나타내는 `top` 인덱스도 포함합니다. 이 인덱스는 스택에 저장된 마지막 요소의 위치를 가리키는 용도로 사용됩니다.
(아직 스택을 배우지 않아서 '`top` 인덱스', '스택에 저장된 마지막 요소의 위치' 이런 표현이 익숙하지 않을 수 있습니다. 추후에 스택과 같은 자료구조에 대해서도 배우게 되니 실질적인 의미는 아직 모르셔도 괜찮습니다.)

---

**2. 다음 함수의 문제점으로 적절한 것은?
```c
int *allocateArray(int size) {
    return malloc(size * sizeof(int));
}
```

- [x]  `malloc`으로 할당한 메모리의 크기가 충분하지 않아, 특정 인덱스로 접근할 때 힙 오버플로우가 발생할 수 있다.
- [ ] `malloc`으로 할당한 메모리는 자동으로 해제되므로 `free`를 호출할 필요가 없다.
- [x]  `allocateArray` 함수는 `size`에 음수 값을 전달할 수 있기 때문에, 동적 할당이 실패하고 `array` 포인터는 `NULL`이 될 수 있다.
- [ ] `allocateArray` 함수는 올바른 크기의 메모리 블록을 할당하기 때문에 문제가 발생할 가능성이 없다.


**답 : 1, 3**

이 코드의 주된 문제는 `size` 변수의 값에 대한 검증이 없다는 것입니다. 음수 값이나 예상치 못한 큰 값이 `size`로 전달되면, `malloc`은 올바르지 않은 양의 메모리를 할당하려 시도하고, 그 결과로 `NULL`을 반환할 수 있습니다. 마찬가지로, 할당된 메모리 크기가 실제 필요한 크기보다 작을 경우, 배열의 유효한 인덱스를 넘어서 접근함으로써 힙 오버플로우가 발생할 위험이 있습니다.

---

**3. 다음 코드에서 파일 입출력 작업이 끝난 후 필요한 조치로 올바른 것은?
```c
FILE *file = fopen("example.txt", "r+");
fread(buffer, sizeof(char), 100, file);
rewind(file);
fwrite(buffer, sizeof(char), 100, file);
// 필요한 조치 작성
```

- [ ]  `fflush(file);`
- [x]  `fclose(file);`
- [ ]  `file = fclose();`
- [ ]  `file = null;`

**답 : 2**

`fclose(file);`는 파일 입출력 작업이 끝난 후에 필요한 올바른 코드입니다. `fflush(file);`는 파일 스트림의 출력 버퍼를 비우지만 파일을 닫지는 않으며, `file = fclose();`와 `file = null;`은 올바르지 않은 문법입니다.

---

**4. 다음 코드에서 `fseek` 함수를 사용한 결과로 올바른 것은?
```c
FILE *file = fopen("example.txt", "r+");
fseek(file, -2, SEEK_END);
fprintf(file, "XY");
fclose(file);
```

- [ ]  파일의 끝에서부터 2바이트 앞으로 이동한 후, "XY"를 쓸 것이다.
- [x]  파일의 마지막에서 두 번째 바이트를 "XY"로 덮어쓸 것이다.
- [ ]  `fseek`는 `SEEK_END`를 사용할 때 음수를 인자로 취할 수 없으므로 오류가 발생한다.
- [ ]  파일의 끝에서 2바이트 뒤에 "XY"를 추가할 것이다.

**답 : 2**

`fseek` 함수를 `SEEK_END`와 함께 사용하면 파일의 끝을 기준으로 위치를 이동할 수 있으며, 음수를 이용하여 파일 끝에서부터 거꾸로 이동할 수 있습니다. 따라서 이 코드는 파일의 마지막에서 두 번째 바이트 위치에 "XY"를 쓰게 됩니다.

---

**5. UNIX 시스템에서 `read` 시스템 호출을 사용할 때, 적절한 사용법은?
```c
char buffer[100];
int nbytes = read(3, buffer, 100);
```

- [x]  위 코드는 파일 디스크립터 3번에서 최대 100바이트를 `buffer`로 읽어들인다.
- [ ]  `read` 함수는 파일 디스크립터 대신 `FILE *` 타입을 사용해야 한다.
- [ ]  파일 디스크립터 3번은 존재하지 않으므로 이 코드는 실패할 것이다.
- [ ]  `read` 함수는 문자열만 읽을 수 있으므로 `buffer`는 문자열 타입이어야 한다.

**답 : 1**

1. `read` 시스템 호출은 주어진 파일 디스크립터에서 데이터를 읽어들이는 데 사용되며, 이 경우 파일 디스크립터 3번에서 최대 100바이트를 읽어 `buffer`에 저장합니다. 
2. `read` 함수는 표준 C 라이브러리의 `fread`와 달리 파일 디스크립터를 사용하는 UNIX 시스템 호출입니다.
3. 이 보기는 상황에 따라 달라질 수 있습니다. 파일 디스크립터 3이 실제로 열린 파일을 가리키고 있다면 코드는 성공적으로 실행될 것입니다. 그러나 일반적으로 파일 디스크립터 0, 1, 2는 각각 표준 입력, 표준 출력, 표준 오류를 가리키며, 파일 디스크립터 3이 존재하기 위해서는 프로그램 내에서 추가적인 파일을 열어야 합니다.
4. `read` 함수는 바이너리 데이터를 포함한 어떠한 종류의 데이터도 읽을 수 있으며, 읽은 데이터를 `buffer`에 저장합니다.