### 포인터 ~ 구조체
- 포인터 기본적인 사용법
- 포인터와 배열 사이의 관계
- Call by Value, Call by Reference
- 이중 포인터
- 문자열관련 함수들
- 구조체의 중첩과 typedef
---
**1. 다음 코드의 출력 결과로 올바른 것은?**
```c
int a = 5;
int *b = &a;
int **c = &b;

printf("%d %d %d\n", a, *b, **c);
```

- [x]  5 5 5
- [ ]  주소 주소 5
- [ ]  5 주소 주소
- [ ]  주소 5 5

**답 : 1**
`a`는 정수 변수, `*b`는 `a`의 주소에 있는 정수값, `**c`는 `b`의 주소에 있는 주소에 있는 정수값을 의미합니다. 따라서 코드의 출력 결과는 `5 5 5`가 됩니다. 

---
**2. 다음 중 배열에 관한 설명으로 옳지 않은 것은 무엇인가?**

- [ ]  배열 이름은 배열의 첫 번째 요소를 가리키는 포인터 상수로 사용될 수 있다.
- [ ]  배열 이름을 사용하여 배열의 각 요소에 접근할 수 있다.
- [x]  배열 이름은 포인터 변수이므로, 다른 주소로 변경이 가능하다.
- [ ]  함수에 배열을 전달할 때 배열 이름을 사용하여 배열의 참조를 전달한다.

**답 : 3**

배열 이름은 상수 포인터로, 배열의 첫 번째 요소를 가리키는 주소를 담고 있습니다. 배열 이름은 상수이므로 다른 주소로 변경할 수 없습니다. 

---

**3. 다음 중 참조에 대한 설명으로 잘못된 것은 무엇인가?**

- [ ]  Call by Value는 함수에 값을 복사하여 전달하는 반면, Call by Reference는 주소를 전달한다.
- [x]  Call by Reference를 사용하는 경우, 함수 외부의 변수 값은 변경되지 않는다.
- [ ]  Call by Value를 사용하면 함수 내부의 값 변경이 원본 변수에 영향을 미치지 않는다.
- [ ]  Call by Reference는 함수 내부에서 원본 변수의 값을 변경할 수 있게 해준다.

**답 : 2**
Call by Reference를 사용하면 함수가 매개변수로 받은 주소를 통해 원본 변수의 값을 변경할 수 있습니다. 선택지 2가 잘못된 설명입니다.

---

**4. 다음 중 `strcpy` 함수의 사용에 관한 설명으로 잘못된 것은 무엇인가?**

- [ ]  `strcpy` 함수는 NULL 종료 문자를 포함하여 문자열을 복사한다.
- [ ]  `strcpy` 함수는 목적지 버퍼가 충분히 크다고 가정하고 동작한다.
- [ ]  `strcpy` 함수의 반환 값은 목적지 문자열의 주소이다.
- [x]  `strcpy` 함수는 복사하는 문자열의 길이를 자동으로 검사하여 버퍼 오버플로우를 방지한다.

**답 : 4**
`strcpy` 함수는 복사할 문자열의 길이를 검사하지 않으므로 버퍼 오버플로우를 방지하지 않습니다. 추후에 C언어를 깊이 이해하게 되면, 버퍼 오버플로우와 같은 버그를 이용하여 공격을 진행할 수 있게 됩니다.

---

**5. 다음 코드에서 올바르게 typedef를 사용하여 구조체를 선언한 후, `createPoint` 함수를 구현한 것은?**
```c
typedef struct Point {
    int x;
    int y;
} Point;

Point createPoint(int x, int y);
```

- [ ]  `Point createPoint(int x, int y) { Point p; p.x = x; p.y = y; return p; }`
- [x]  `Point createPoint(int x, int y) { return (Point){x, y}; }`
- [ ]  `Point createPoint(int x, int y) { return Point(x, y); }`
- [ ]  `Point createPoint(int x, int y) { return new Point{x, y}; }`

**답 : 2**

`(Point){x, y}`와 같은 구문을 사용하여 구조체를 초기화하고 반환할 수 있습니다. 

--- 

**6. 다음 코드에서 `ptr`이 가리키는 최종 값은 무엇인가?
```c
int array[] = {10, 20, 30, 40, 50};
int *ptr = array;

*(++ptr) += 123;
*(ptr++) += 123;
```

- [ ]  `ptr`은 `array[2]`을 가리키고 그 값은 153이다.
- [x]  `ptr`은 `array[2]`을 가리키고 그 값은 30이다.
- [ ]  `ptr`은 `array[3]`을 가리키고 그 값은 163이다.
- [ ]  `ptr`은 `array[1]`을 가리키고 그 값은 143이다.

**답 : 2

첫 번째 연산에서 `ptr`은 `array[0]`을 가리키고 전위 증가 연산자에 의해 값 변경 후 `ptr`이 `array[1]`을 가리키게 됩니다. 두 번째 연산에서도 비슷하지만 `array[2]`의 값을 변경할 것 같지만, 후위 연산이기 때문에 실제로는 3번째 인덱스에 `+=` 연산이 적용되지 않습니다. 따라서 `ptr`은 `array[2]`를 가리키지만 값은 원래의 값인 30입니다.

---

**7. 다음 코드가 컴파일되고 실행되었을 때, `printf`의 출력 결과는 무엇인가?
```c
void foo(int a[]) {
    a[0] = 2;
    a[1] ^= a[0];
}

int main() {
    void (*fptr)(int []);
    int b[2] = {0, 1};
    fptr = foo;
    fptr(b);
    printf("%d, %d", b[0], b[1]);
}
```

- [ ]  `2, 1`
- [x]  `2, 3`
- [ ]  `2, 0`
- [ ]  `0, 2`

**답 : 2**

`foo` 함수는 배열의 첫 번째 요소를 `2`로 설정합니다. 그 다음, `a[1]`의 값을 `a[1]`과 `a[0]`의 XOR 연산 결과로 업데이트합니다. 초기에 `b[1]`의 값은 `1`이고, `b[0]`의 값은 `2`로 바뀌었으므로, XOR 연산의 결과는 `2 XOR 1 = 3`이 됩니다. 따라서 출력 결과는 `2, 3`입니다.

---

**8. 다음 구조체 `Data`의 크기는 얼마인가?
```c
typedef struct {
    char a;
    int b; 
    char c;
} Data;
```

- [ ]  6 bytes
- [ ]  10 bytes
- [x]  12 bytes
- [ ]  8 bytes

**답 : 3

char 1바이트 2개, int 4바이트 1개로 총 6바이트라고 생각할 수 있지만, 대부분의 컴파일러는 메모리 정렬(패딩)을 수행하여 데이터를 효율적으로 접근할 수 있도록 합니다. 이 경우, `char a` 다음에 3바이트의 패딩이 들어가므로 전체 구조체의 크기는 12바이트가 됩니다.

---
