from z3 import *

# # 변수들을 초기화합니다. 각 변수는 BitVec 타입으로 8비트 크기를 가집니다.
# a60 = BitVec('a60', 8) # 32 또는 16 또는 8 아마 8일듯
# a64 = BitVec('a64', 8)
# a68 = BitVec('a68', 8)
# a6C = BitVec('a6C', 8)
# a70 = BitVec('a70', 8)
# a74 = BitVec('a74', 8)
# a78 = BitVec('a78', 8)
# a7C = BitVec('a7C', 8)
# a80 = BitVec('a80', 8)
# a84 = BitVec('a84', 8)
# a88 = BitVec('a88', 8)
# a8C = BitVec('a8C', 8)
# a90 = BitVec('a90', 8)
# a94 = BitVec('a94', 8)
# a98 = BitVec('a98', 8)
# a9C = BitVec('a9C', 8)
# aA0 = BitVec('aA0', 8)
# aA4 = BitVec('aA4', 8)
# aA8 = BitVec('aA8', 8)
# aAC = BitVec('aAC', 8)
# aB0 = BitVec('aB0', 8)


a60 = int() 
a64 = int()
a68 = int()
a6C = int()
a70 = int()
a74 = int()
a78 = int()
a7C = int()
a80 = int()
a84 = int()
a88 = int()
a8C = int()
a90 = int()
a94 = int()
a98 = int()
a9C = int()
aA0 = int()
aA4 = int()
aA8 = int()
aAC = int()
aB0 = int()

# 솔버 인스턴스를 생성합니다.
s = Solver()

# 제약 조건들을 추가합니다.
s.add(a64 == a70)
s.add(a74 == 118)
s.add(a78 == 162)
s.add(aA8 == 168)
s.add(a60 % 100 - 6 == a88)
s.add(a68 % 100 == 34)
s.add(2*(a78 + a68) == 592)
# s.add(a70 % 100 == 30)
# s.add(a74 < a78)
# s.add(a74 < a8C)
# s.add(a7C % 100 == 74)
# s.add(a80 == aA8)
# s.add(a84 == a70)
# s.add(a84 > a88)
# s.add(a60 < a64)
# s.add(a88 % 100 == 80)
# s.add(a8C == a90)
# s.add(2 * (a90 + a64) == 528)
# s.add(a94 > aA8)
# s.add(a68 > a60)
# s.add(a9C % 100 == 48)
# s.add(a9C + 2 * aA0 - aA4 == 226)
# s.add((a98 + a9C - 296)< 2)
# s.add(aAC < a60)
# s.add(a9C > aA0)
# s.add(aA4 % 100 == 78)
# s.add((a74 * aA0 - 9204)< 4)
# s.add(a88 + a80 + a6C == 406)
# s.add(aB0 + a9C == 154)
# s.add(aAC == aB0)
# s.add(a7C > a80)
# s.add(a9C > aA0)
# s.add(a9C < a7C)
# s.add(a98 > a60)
# s.add(a90 + a98 + a94 == 454)


# 솔버를 실행합니다.
if s.check() == sat:
    print("해답이 존재합니다!")
    m = s.model()
    for d in m.decls():
        eax=m[d].as_long()
        #print("%s = 0x%x" % (d.name(), eax))
        print("%d" % (eax), end="")
else:
    print("해답을 찾을 수 없습니다.")


